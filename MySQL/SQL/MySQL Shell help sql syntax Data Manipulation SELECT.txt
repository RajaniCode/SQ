
$ export PATH=$PATH:"/C/Users/rajanis/Downloads/MySQL/MySQL Shell/mysql-shell-8.0.25-windows-x86-64bit/bin/"

$ winpty mysqlsh --version
C:/Users/rajanis/Downloads/MySQL/MySQL Shell/mysql-shell-8.0.25-windows-x86-64bit/bin/mysqlsh.exe   Ver 8.0.25 for Win64 on x86_64 - for MySQL 8.0.25 (MySQL Community Server (GPL))

$ winpty mysqlsh --sql
MySQL Shell 8.0.25

Copyright (c) 2016, 2021, Oracle and/or its affiliates.
Oracle is a registered trademark of Oracle Corporation and/or its affiliates.
Other names may be trademarks of their respective owners.

Type '\help' or '\?' for help; '\quit' to exit.
 MySQL  SQL > \?
The Shell Help is organized in categories and topics. To get help for a
specific category or topic use: \? <pattern>

The <pattern> argument should be the name of a category or a topic.

The pattern is a filter to identify topics for which help is required, it can
use the following wildcards:

- ? matches any single character.
- * matches any character sequence.

The following are the main help categories:

 - Shell Commands Provides details about the available built-in shell commands.
 - SQL Syntax     Entry point to retrieve syntax help on SQL statements.

The available topics include:

- The available shell commands.
- Any word that is part of an SQL statement.
- Command Line - invoking built-in shell functions without entering interactive
  mode.

SHELL COMMANDS

The shell commands allow executing specific operations including updating the
shell configuration.

The following shell commands are available:

 - \                   Start multi-line input when in SQL mode.
 - \connect    (\c)    Connects the shell to a MySQL server and assigns the
                       global session.
 - \disconnect         Disconnects the global session.
 - \edit       (\e)    Launch a system editor to edit a command to be executed.
 - \exit               Exits the MySQL Shell, same as \quit.
 - \G                  Send command to mysql server, display result vertically.
 - \g                  Send command to mysql server.
 - \help       (\?,\h) Prints help information about a specific topic.
 - \history            View and edit command line history.
 - \js                 Switches to JavaScript processing mode.
 - \nopager            Disables the current pager.
 - \nowarnings (\w)    Don't show warnings after every statement.
 - \option             Allows working with the available shell options.
 - \pager      (\P)    Sets the current pager.
 - \py                 Switches to Python processing mode.
 - \quit       (\q)    Exits the MySQL Shell.
 - \reconnect          Reconnects the global session.
 - \rehash             Refresh the autocompletion cache.
 - \show               Executes the given report with provided options and
                       arguments.
 - \source     (\.)    Loads and executes a script from a file.
 - \sql                Executes SQL statement or switches to SQL processing
                       mode when no statement is given.
 - \status     (\s)    Print information about the current global session.
 - \system     (\!)    Execute a system shell command.
 - \use        (\u)    Sets the active schema.
 - \warnings   (\W)    Show warnings after every statement.
 - \watch              Executes the given report with provided options and
                       arguments in a loop.

EXAMPLES
\? sql syntax
      Displays the main SQL help categories.

\? select
      Displays information about the SELECT SQL statement.
 MySQL  SQL > \? sql syntax
SQL help requires the Shell to be connected to a MySQL server.

 MySQL  SQL > \connect --mysql root@localhost
Creating a Classic session to 'root@localhost'
Please provide the password for 'root@localhost': *****************
Save password for 'root@localhost'? [Y]es/[N]o/Ne[v]er (default No): v
Fetching schema names for autocompletion... Press ^C to stop.
Your MySQL connection id is 23
Server version: 10.4.14-MariaDB mariadb.org binary distribution
No default schema selected; type \use <schema> to set one.
 MySQL  localhost:3306  SQL > \? sql syntax
Found several entries matching sql syntax

The following topics were found at the SQL Syntax category:

- Account Management
- Administration
- Compound Statements
- Data Definition
- Data Manipulation
- Data Types
- Functions
- Functions and Modifiers for Use with GROUP BY
- Geographic Features
- Help Metadata
- Language Structure
- Optimization and Indexes
- Plugins
- Procedures
- Sequences
- Storage Engines
- Table Maintenance
- Transactions
- User-Defined Functions
- Utility

For help on a specific topic use: \? <topic>

e.g.: \? Account Management
 MySQL  localhost:3306  SQL > \? DATA MANIPULATION
Found several entries matching DATA MANIPULATION

The following topics were found at the SQL Syntax category:

- CALL
- Concurrent Inserts
- DELETE
- DO
- DUAL
- EXCEPT
- FOR UPDATE
- GROUP BY
- HANDLER Commands
- HIGH_PRIORITY and LOW_PRIORITY
- IGNORE
- INSERT
- INSERT - Default &amp; Duplicate Values
- INSERT DELAYED
- INSERT IGNORE
- INSERT ON DUPLICATE KEY UPDATE
- INSERT SELECT
- INTERSECT
- JOIN Syntax
- LIMIT
- LOAD DATA INFILE
- LOAD XML
- LOCK IN SHARE MODE
- Non-Recursive Common Table Expressions Overview
- ORDER BY
- PROCEDURE
- Recursive Common Table Expressions Overview
- REPLACE
- SELECT
- SELECT INTO DUMPFILE
- SELECT INTO OUTFILE
- SELECT WITH ROLLUP
- UNION
- UPDATE
- WITH

For help on a specific topic use: \? <topic>

e.g.: \? CALL
 MySQL  localhost:3306  SQL > \? SELECT
Syntax
------
SELECT
 [ALL | DISTINCT | DISTINCTROW]
 [HIGH_PRIORITY]
 [STRAIGHT_JOIN]
 [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]
 [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS]
 select_expr [, select_expr ...]
 [ FROM table_references
 [WHERE where_condition]
 [GROUP BY {col_name | expr | position} [ASC | DESC], ...
[WITH ROLLUP]]
 [HAVING where_condition]
 [ORDER BY {col_name | expr | position} [ASC | DESC], ...]
 [LIMIT {[offset,] row_count | row_count OFFSET offset}]
 procedure|[PROCEDURE procedure_name(argument_list)]
 [INTO OUTFILE 'file_name' [CHARACTER SET charset_name]
[export_options]

INTO DUMPFILE 'file_name' | INTO var_name [, var_name] ] |


 [[FOR UPDATE | LOCK IN SHARE MODE] [WAIT n | NOWAIT] ] ]

export_options:
 [{FIELDS | COLUMNS}
 [TERMINATED BY 'string']
 [[OPTIONALLY] ENCLOSED BY 'char']
 [ESCAPED BY 'char']
 ]
 [LINES
 [STARTING BY 'string']
 [TERMINATED BY 'string']
 ]

Description
-----------
SELECT is used to retrieve rows selected from one or more
tables, and can include UNION statements and subqueries.
Each select_expr expression indicates a column or data that
you want to retrieve. You
must have at least one select expression. See Select
Expressions below.

The FROM clause indicates the table or tables from which to
retrieve rows.
Use either a single table name or a JOIN expression. See
JOIN
for details. If no table is involved, FROM DUAL can be
specified.

The PARTITION clause was introduced in MariaDB 10.0. See
Partition Pruning and Selection for details.
Each table can also be specified as db_name.tabl_name. Each
column can also be specified as tbl_name.col_name or even
db_name.tbl_name.col_name. This allows to write queries
which involve multiple databases. See Identifier Qualifiers
for syntax details.

The WHERE clause, if given, indicates the condition or
 conditions that rows must satisfy to be selected.
 where_condition is an expression that evaluates to true for
 each row to be selected. The statement selects all rows if
there is no WHERE
 clause.
In the WHERE clause, you can use any of the functions and
 operators that MariaDB supports, except for aggregate
(summary) functions. See Functions and Operators and
Functions and Modifiers for use with GROUP BY (aggregate).

Use the ORDER BY clause to order the results.

Use the LIMIT clause allows you to restrict the results to
only
a certain number of rows, optionally with an offset.

Use the GROUP BY and HAVING clauses to group
rows together when they have columns or computed values in
common.

SELECT can also be used to retrieve rows computed without
reference to
any table.

Select Expressions

A SELECT statement must contain one or more select
expressions, separated
by commas. Each select expression can be one of the
following:
The name of a column.
Any expression using functions and operators.
* to select all columns from all tables in the FROM clause.
tbl_name.* to select all columns from just the table
tbl_name.

When specifying a column, you can either use just the column
name or qualify the column
name with the name of the table using tbl_name.col_name. The
qualified form is
useful if you are joining multiple tables in the FROM
clause. If you do not qualify the
column names when selecting from multiple tables, MariaDB
will try to find the column in
each table. It is an error if that column name exists in
multiple tables.

You can quote column names using backticks. If you are
qualifying column names
with table names, quote each part separately as
`tbl_name`.`col_name`.

If you use any grouping functions
in any of the select expressions, all rows in your results
will be implicitly grouped, as if
you had used GROUP BY NULL.

DISTINCT

A query may produce some identical rows. By default, all
rows are retrieved, even when their values are the same. To
explicitly specify that you want to retrieve identical rows,
use the ALL option. If you want duplicates to be removed
from the resultset, use the DISTINCT option. DISTINCTROW is
a synonym for DISTINCT. See also COUNT DISTINCT and SELECT
UNIQUE in Oracle mode.

INTO

The INTO clause is used to specify that the query results
should be written to a file or variable.
SELECT INTO OUTFILE - formatting and writing the result to
an external file.
SELECT INTO DUMPFILE - binary-safe writing of the
unformatted results to an external file.
SELECT INTO Variable - selecting and setting variables.

The reverse of SELECT INTO OUTFILE is LOAD DATA.

WAIT/NOWAIT

Set the lock wait timeout. See WAIT and NOWAIT.

PROCEDURE

Passes the whole result set to a C Procedure. See PROCEDURE
and PROCEDURE ANALYSE (the only built-in procedure not
requiring the server to be recompiled).


max_statement_time clause

By using max_statement_time in conjunction with SET
STATEMENT, it is possible to limit the execution time of
individual queries. For example:

SET STATEMENT max_statement_time=100 FOR
 SELECT field1 FROM table_name ORDER BY field1;



URL: https://mariadb.com/kb/en/select/
 MySQL  localhost:3306  SQL > \? CALL
Syntax
------
CALL sp_name([parameter[,...]])
CALL sp_name[()]

Description
-----------
The CALL statement invokes a stored procedure that was
defined previously with CREATE PROCEDURE.

Stored procedure names can be specified as
database_name.procedure_name. Procedure names and database
names can be quoted with backticks (). This is necessary if
they are reserved words, or contain special characters. See
identifier qualifiers for details.

Before MySQL 5.1.13, stored procedures that take no
arguments required parentheses. In current releases of
MariaDB, CALL p() and CALL p are equivalent.

If parentheses are used, any number of spaces, tab
characters and new line characters is allowed between the
procedure's name and the open parenthesis.

CALL can pass back values to its caller using parameters
that are declared as OUT or INOUT
parameters. If no value is assigned to an OUT parameter,
NULL is assigned (and its former value is lost). To pass
such values from another stored program you can use
user-defined variables, local variables or routine's
parameters; in other contexts, you can only use user-defined
variables.

CALL can also be executed as a prepared statement.
Placeholders can be used for IN parameters in all versions
of MariaDB; for OUT and INOUT parameters, placeholders can
be used since MariaDB 5.5.

When the procedure returns, a client program can also obtain
the
number of rows affected for the final statement executed
within the routine: At
the SQL level, call the ROW_COUNT() function; from the C
API, call the mysql_affected_rows() function.

If the CLIENT_MULTI_RESULTS API flag is set, CALL can return
any number of resultsets and the called stored procedure can
execute prepared statements. If it is not set, at most one
resultset can be returned and prepared statements cannot be
used within procedures.










URL: https://mariadb.com/kb/en/call/
 MySQL  localhost:3306  SQL > \? Concurrent Inserts
The MyISAM storage engine supports concurrent inserts. This
feature allows SELECT statements to be executed during
INSERT operations, reducing contention.

Whether concurrent inserts can be used or not depends on the
value of the concurrent_insert server system variable:
NEVER (0) disables concurrent inserts.
AUTO (1) allows concurrent inserts only when the target
table has no free blocks (no data in the middle of the table
has been deleted after the last OPTIMIZE TABLE). This is the
default.
ALWAYS (2) always enables concurrent inserts.

If the binary log is used, CREATE TABLE ... SELECT and
INSERT ... SELECT statements cannot use concurrent inserts.
These statements acquire a read lock on the table, so
concurrent inserts will need to wait. This way the log can
be safely used to restore data.

Concurrent inserts is not used by slaves with the row based
replication (see binary log formats).

If an INSERT statement contain the HIGH_PRIORITY clause,
concurrent inserts cannot be used. INSERT ... DELAYED is
usually unneeded if concurrent inserts are enabled.

LOAD DATA INFILE uses concurrent inserts if the CONCURRENT
keyword is specified and concurrent_insert is not NEVER.
This makes the statement slower (even if no other sessions
access the table) but reduces contention.

LOCK TABLES allows non-conflicting concurrent inserts if a
READ LOCAL lock is used. Concurrent inserts are not allowed
if the LOCAL keyword is omitted.

Notes

The decision to enable concurrent insert for a table is done
when the table is opened. If you change the value of
concurrent_insert it will only affect new opened tables. If
you want it to work for also for tables in use or cached,
you should do FLUSH TABLES after setting the variable.



URL: https://mariadb.com/kb/en/concurrent-inserts/
 MySQL  localhost:3306  SQL > \? DELETE
Syntax
------
Single-table syntax:

DELETE [LOW_PRIORITY] [QUICK] [IGNORE]
 FROM tbl_name [PARTITION (partition_list)]
 [WHERE where_condition]
 [ORDER BY ...]
 [LIMIT row_count]
 [RETURNING select_expr
 [, select_expr ...]]

Multiple-table syntax:

DELETE [LOW_PRIORITY] [QUICK] [IGNORE]
 tbl_name[.*] [, tbl_name[.*]] ...
 FROM table_references
 [WHERE where_condition]

Or:

DELETE [LOW_PRIORITY] [QUICK] [IGNORE]
 FROM tbl_name[.*] [, tbl_name[.*]] ...
 USING table_references
 [WHERE where_condition]

Trimming history:

DELETE HISTORY
 FROM tbl_name [PARTITION (partition_list)]
 [BEFORE SYSTEM_TIME [TIMESTAMP|TRANSACTION] expression]

Description
-----------
Option | Description |

LOW_PRIORITY | Wait until all SELECT's are done before
starting the statement. Used with storage engines that uses
table locking (MyISAM, Aria etc). See HIGH_PRIORITY and
LOW_PRIORITY clauses for details. |

QUICK | Signal the storage engine that it should expect that
a lot of rows are deleted. The storage engine engine can do
things to speed up the DELETE like ignoring merging of data
blocks until all rows are deleted from the block (instead of
when a block is half full). This speeds up things at the
expanse of lost space in data blocks. At least MyISAM and
Aria support this feature. |

IGNORE | Don't stop the query even if a not-critical error
occurs (like data overflow). See How IGNORE works for a full
description. |

For the single-table syntax, the DELETE statement deletes
rows
from tbl_name and returns a count of the number of deleted
rows. This count can
be obtained by calling the ROW_COUNT() function. The
WHERE clause, if given, specifies the conditions that
identify
which rows to delete. With no WHERE clause, all rows are
deleted. If the ORDER BY clause is specified, the rows are
deleted in the order that is specified. The LIMIT clause
places a limit on the number of rows that can be deleted.

For the multiple-table syntax, DELETE deletes from each
tbl_name the rows that satisfy the conditions. In this case,
ORDER BY and LIMIT> cannot be used. A DELETE can also
reference tables which are located in different databases;
see Identifier Qualifiers for the syntax.

where_condition is an expression that evaluates to true for
each row to be deleted. It is specified as described in
SELECT.

Currently, you cannot delete from a table and select from
the same
table in a subquery.

You need the DELETE privilege on a table to delete rows from
it. You need only the SELECT privilege for any columns that
are only read, such as those named in the WHERE clause. See
GRANT.

The PARTITION clause was introduced in MariaDB 10.0. See
Partition Pruning and Selection for details.

As stated, a DELETE statement with no WHERE
clause deletes all rows. A faster way to do this, when you
do not need to know
the number of deleted rows, is to use TRUNCATE TABLE.
However,
within a transaction or if you have a lock on the table,
TRUNCATE TABLE cannot be used whereas DELETE
can. See TRUNCATE TABLE, and
LOCK.

From MariaDB 10.0.5, it is possible to return a resultset of
the deleted rows for a single table to the client by using
the syntax DELETE ... RETURNING select_expr [, select_expr2
...]]

Any of SQL expression that can be calculated from a single
row fields is allowed. Subqueries are allowed. The AS
keyword is allowed, so it is possible to use aliases.

The use of aggregate functions is not allowed. RETURNING
cannot be used in multi-table DELETEs.

Same Source and Target Table

Until MariaDB 10.3.1, deleting from a table with the same
source and target was not possible. From MariaDB 10.3.1,
this is now possible. For example:

DELETE FROM t1 WHERE c1 IN (SELECT b.c1 FROM t1 b WHERE
b.c2=0);

One can use DELETE HISTORY to delete historical information
from System-versioned tables.

Examples
--------
How to use the ORDER BY and LIMIT clauses:

DELETE FROM page_hit ORDER BY timestamp LIMIT 1000000;

How to use the RETURNING clause:

DELETE FROM t RETURNING f1;

+------+
| f1 |
+------+
| 5 |
| 50 |
| 500 |
+------+

The following statement joins two tables: one is only used
to satisfy a WHERE condition, but no row is deleted from it;
rows from the other table are deleted, instead.

DELETE post FROM blog INNER JOIN post WHERE blog.id =
post.blog_id;

Deleting from the Same Source and Target

CREATE TABLE t1 (c1 INT, c2 INT);
DELETE FROM t1 WHERE c1 IN (SELECT b.c1 FROM t1 b WHERE
b.c2=0);

Until MariaDB 10.3.1, this returned:

ERROR 1093 (HY000): Table 't1' is specified twice, both as
a target for 'DELETE'
 and as a separate source for

From MariaDB 10.3.1:

Query OK, 0 rows affected (0.00 sec)



URL: https://mariadb.com/kb/en/delete/
 MySQL  localhost:3306  SQL > \? DO
Syntax
------
DO expr [, expr] ...

Description
-----------
 DO executes the expressions but does not return any
results. In most respects, DO is shorthand for
 SELECT expr, ..., but has the advantage that it is slightly
faster when you do not care about the result.

 DO is useful primarily with functions that have side
 effects, such as RELEASE_LOCK().










URL: https://mariadb.com/kb/en/do/
 MySQL  localhost:3306  SQL > \? DUAL
Description
-----------
You are allowed to specify DUAL as a dummy table name in
situations where no tables are referenced, such as the
following SELECT statement:

SELECT 1 + 1 FROM DUAL;

+-------+
| 1 + 1 |
+-------+
| 2 |
+-------+

 DUAL is purely for the convenience of people who require
 that all SELECT statements should have
 FROM and possibly other clauses. MariaDB ignores the
 clauses. MariaDB does not require FROM DUAL if no tables
 are referenced.

FROM DUAL could be used when you only SELECT computed
values, but require a WHERE clause, perhaps to test that a
script correctly handles empty resultsets:

SELECT 1 FROM DUAL WHERE FALSE;

Empty set (0.00 sec)



URL: https://mariadb.com/kb/en/dual/
 MySQL  localhost:3306  SQL > \? EXCEPT
EXCEPT was introduced in MariaDB 10.3.0.

The result of EXCEPT is all records of the left SELECT
result set except records which are in right SELECT result
set, i.e. it is subtraction of two result sets.

Syntax
------
SELECT ...
(INTERSECT | EXCEPT | UNION [ALL | DISTINCT]) SELECT ...
[(INTERSECT | EXCEPT | UNION [ALL | DISTINCT]) SELECT ...]
[ORDER BY [column [, column ...]]]
[LIMIT {[offset,] row_count | row_count OFFSET offset}]

Please note:
ALL is not supported by EXCEPT (and it is difficult to make
sense of ALL with EXCEPT).
Brackets for explicit operation precedence are not
supported; use a subquery in the FROM clause as a
workaround).

Description
-----------
MariaDB has supported EXCEPT and INTERSECT in addition to
UNION since MariaDB 10.3.

All behavior for naming columns, ORDER BY and LIMIT is the
same as for UNION.

EXCEPT implicitly supposes a DISTINCT operation.

The result of EXCEPT is all records of the left SELECT
result except records which are in right SELECT result set,
i.e. it is subtraction of two result sets.

EXCEPT and UNION have the same operation precedence.


Parentheses

From MariaDB 10.4.0, parentheses can be used to specify
precedence. Before this, a syntax error would be returned.

Examples
--------
Show customers which are not employees:

(SELECT e_name AS name, email FROM customers)
EXCEPT
(SELECT c_name AS name, email FROM employees);

Difference between UNION, EXCEPT and INTERSECT:

CREATE TABLE seqs (i INT);
INSERT INTO seqs VALUES (1),(2),(3),(4),(5),(6);

SELECT i FROM seqs WHERE i =3;

+------+
| i |
+------+
| 1 |
| 2 |
| 3 |
| 4 |
| 5 |
| 6 |
+------+

SELECT i FROM seqs WHERE i =3;

+------+
| i |
+------+
| 1 |
| 2 |
+------+

SELECT i FROM seqs WHERE i =3;

+------+
| i |
+------+
| 3 |
+------+

Parentheses for specifying precedence, from MariaDB 10.4.0

CREATE OR REPLACE TABLE t1 (a INT);
CREATE OR REPLACE TABLE t2 (b INT);
CREATE OR REPLACE TABLE t3 (c INT);

INSERT INTO t1 VALUES (1),(2),(3),(4);
INSERT INTO t2 VALUES (5),(6);
INSERT INTO t3 VALUES (1),(6);

((SELECT a FROM t1) UNION (SELECT b FROM t2)) EXCEPT (SELECT
c FROM t3);
+------+
| a |
+------+
| 2 |
| 3 |
| 4 |
| 5 |
+------+

(SELECT a FROM t1) UNION ((SELECT b FROM t2) EXCEPT (SELECT
c FROM t3));
+------+
| a |
+------+
| 1 |
| 2 |
| 3 |
| 4 |
| 5 |
+------+



URL: https://mariadb.com/kb/en/except/
 MySQL  localhost:3306  SQL > \? FOR UPDATE
The FOR UPDATE clause of SELECT applies only when autocommit
is set to 0 or the SELECT is enclosed in a transaction. A
lock is acquired on the rows, and other transactions are
prevented from writing the rows, acquire locks, and from
reading them (unless their isolation level is READ
UNCOMMITTED).

If autocommit is set to 1, the LOCK IN SHARE MODE and FOR
UPDATE clauses have no effect.

If the isolation level is set to SERIALIZABLE, all plain
SELECT statements are converted to SELECT ... LOCK IN SHARE
MODE.

Example

SELECT * FROM trans WHERE period=2001 FOR UPDATE;



URL: https://mariadb.com/kb/en/for-update/
 MySQL  localhost:3306  SQL > \? GROUP BY
Use the GROUP BY clause in a SELECT statement to group rows
together that have the same value in one or more column, or
the same computed value using expressions with any
functions and operators except
grouping functions. When you
use a GROUP BY clause, you will get a single result row for
each group of rows
that have the same value for the expression given in GROUP
BY.

When grouping rows, grouping values are compared as if by
the = operator.
For string values, the = operator ignores trailing
whitespace and may normalize
characters and ignore case, depending on the collation in
use.

You can use any of the grouping functions in your select
expression. Their values will
be calculated based on all the rows that have been grouped
together for each result
row. If you select a non-grouped column or a value computed
from a non-grouped
column, it is undefined which row the returned value is
taken from. This is not permitted if the ONLY_FULL_GROUP_BY
SQL_MODE is used.

You can use multiple expressions in the GROUP BY clause,
separated by commas.
Rows are grouped together if they match on each of the
expressions.

You can also use a single integer as the grouping
expression. If you use an integer n,
the results will be grouped by the nth column in the select
expression.

The WHERE clause is applied before the GROUP BY clause. It
filters non-aggregated
rows before the rows are grouped together. To filter grouped
rows based on aggregate values,
use the HAVING clause. The HAVING clause takes any
expression and evaluates it as
a boolean, just like the WHERE clause. You can use grouping
functions in the HAVING
clause. As with the select expression, if you reference
non-grouped columns in the HAVING
clause, the behavior is undefined.

By default, if a GROUP BY clause is present, the rows in the
output will be sorted by the expressions used in the GROUP
BY. You can also specify ASC or DESC (ascending, descending)
after those expressions, like in ORDER BY. The default is
ASC.

If you want the rows to be sorted by another field, you can
add an explicit ORDER BY. If you don't want the result to
be ordered, you can add ORDER BY NULL.

WITH ROLLUP

The WITH ROLLUP modifer adds extra rows to the resultset
that represent super-aggregate summaries. For a full
description with examples, see SELECT WITH ROLLUP.

GROUP BY Examples

Consider the following table that records how many times
each user has played and won a game:

CREATE TABLE plays (name VARCHAR(16), plays INT, wins INT);
INSERT INTO plays VALUES
 ("John", 20, 5),
 ("Robert", 22, 8),
 ("Wanda", 32, 8),
 ("Susan", 17, 3);

Get a list of win counts along with a count:

SELECT wins, COUNT(*) FROM plays GROUP BY wins;

+------+----------+
| wins | COUNT(*) |
+------+----------+
| 3 | 1 |
| 5 | 1 |
| 8 | 2 |
+------+----------+
3 rows in set (0.00 sec)

The GROUP BY expression can be a computed value, and can
refer back to an identifer
specified with AS. Get a list of win averages along with a
count:

SELECT (wins / plays) AS winavg, COUNT(*) FROM plays GROUP
BY winavg;

+--------+----------+
| winavg | COUNT(*) |
+--------+----------+
| 0.1765 | 1 |
| 0.2500 | 2 |
| 0.3636 | 1 |
+--------+----------+
3 rows in set (0.00 sec)

You can use any grouping function
in the select expression. For each win average as above, get
a list of the average play
count taken to get that average:

SELECT (wins / plays) AS winavg, AVG(plays) FROM plays
 GROUP BY winavg;

+--------+------------+
| winavg | AVG(plays) |
+--------+------------+
| 0.1765 | 17.0000 |
| 0.2500 | 26.0000 |
| 0.3636 | 22.0000 |
+--------+------------+
3 rows in set (0.00 sec)

You can filter on aggregate information using the HAVING
clause. The HAVING
clause is applied after GROUP BY and allows you to filter on
aggregate data that is
not available to the WHERE clause. Restrict the above
example to results that involve
an average number of plays over 20:

SELECT (wins / plays) AS winavg, AVG(plays) FROM plays
 GROUP BY winavg HAVING AVG(plays) > 20;

+--------+------------+
| winavg | AVG(plays) |
+--------+------------+
| 0.2500 | 26.0000 |
| 0.3636 | 22.0000 |
+--------+------------+
2 rows in set (0.00 sec)

See Also

SELECT
Joins and Subqueries
LIMIT
ORDER BY
Common Table Expressions
SELECT WITH ROLLUP
SELECT INTO OUTFILE
SELECT INTO DUMPFILE
FOR UPDATE
LOCK IN SHARE MODE
Optimizer Hints










URL: https://mariadb.com/kb/en/group-by/
 MySQL  localhost:3306  SQL > \? HANDLER Commands
Syntax
------
HANDLER tbl_name OPEN [ [AS] alias]
HANDLER tbl_name READ index_name { = | >= | = |

URL: https://mariadb.com/kb/en/handler-commands/
 MySQL  localhost:3306  SQL > \? HIGH_PRIORITY and LOW_PRIORITY
The XtraDB/InnoDB storage engine uses row-level locking to
ensure data integrity. However some storage engines (such as
MEMORY, MyISAM, Aria and MERGE) lock the whole table to
prevent conflicts. These storage engines use two separate
queues to remember pending statements; one is for SELECTs
and the other one is for write statements (INSERT, DELETE,
UPDATE). By default, the latter has a higher priority.

To give write operations a lower priority, the
low_priority_updates server system variable can be set to
ON. The option is available on both the global and session
levels, and it can be set at startup or via the SET
statement.

When too many table locks have been set by write statements,
some pending SELECTs are executed. The maximum number of
write locks that can be acquired before this happens is
determined by the max_write_lock_count server system
variable, which is dynamic.

If write statements have a higher priority (default), the
priority of individual write statements (INSERT, REPLACE,
UPDATE, DELETE) can be changed via the LOW_PRIORITY
attribute, and the priority of a SELECT statement can be
raised via the HIGH_PRIORITY attribute. Also, LOCK TABLES
supports a LOW_PRIORITY attribute for WRITE locks.

If read statements have a higher priority, the priority of
an INSERT can be changed via the HIGH_PRIORITY attribute.
However, the priority of other write statements cannot be
raised individually.

The use of LOW_PRIORITY or HIGH_PRIORITY for an INSERT
prevents Concurrent Inserts from being used.



URL:
https://mariadb.com/kb/en/high_priority-and-low_priority/
 MySQL  localhost:3306  SQL > \? IGNORE
The IGNORE option tells the server to ignore some common
errors.

IGNORE can be used with the following statements:
DELETE
INSERT (see also INSERT IGNORE)
LOAD DATA INFILE
UPDATE
ALTER TABLE
CREATE TABLE ... SELECT
INSERT ... SELECT

The logic used:
Variables out of ranges are replaced with the
maximum/minimum value.

SQL_MODEs STRICT_TRANS_TABLES, STRICT_ALL_TABLES,
NO_ZERO_IN_DATE, NO_ZERO_DATE are ignored.

Inserting NULL in a NOT NULL field will insert 0 ( in a
numerical
 field), 0000-00-00 ( in a date field) or an empty string (
in a character
 field).

Rows that cause a duplicate key error or break a foreign key
constraint are
 not inserted, updated, or deleted.

The following errors are ignored:

Error number | Symbolic error name | Description |

1022 | ER_DUP_KEY | Can't write; duplicate key in table
'%s' |

1048 | ER_BAD_NULL_ERROR | Column '%s' cannot be null |

1062 | ER_DUP_ENTRY | Duplicate entry '%s' for key %d |

1242 | ER_SUBQUERY_NO_1_ROW | Subquery returns more than 1
row |

1264 | ER_WARN_DATA_OUT_OF_RANGE | Out of range value for
column '%s' at row %ld |

1265 | WARN_DATA_TRUNCATED | Data truncated for column
'%s' at row %ld |

1292 | ER_TRUNCATED_WRONG_VALUE | Truncated incorrect %s
value: '%s' |

1366 | ER_TRUNCATED_WRONG_VALUE_FOR_FIELD | Incorrect
integer value |

1369 | ER_VIEW_CHECK_FAILED | CHECK OPTION failed '%s.%s'
|

1451 | ER_ROW_IS_REFERENCED_2 | Cannot delete or update a
parent row |

1452 | ER_NO_REFERENCED_ROW_2 | Cannot add or update a child
row: a foreign key constraint fails (%s) |

1526 | ER_NO_PARTITION_FOR_GIVEN_VALUE | Table has no
partition for value %s |

1586 | ER_DUP_ENTRY_WITH_KEY_NAME | Duplicate entry '%s'
for key '%s' |

1591 | ER_NO_PARTITION_FOR_GIVEN_VALUE_SILENT | Table has no
partition for some existing values |

1748 | ER_ROW_DOES_NOT_MATCH_GIVEN_PARTITION_SET | Found a
row not matching the given partition set |

Ignored errors normally generate a warning.

A property of the IGNORE clause consists in causing
transactional engines and non-transactional engines (like
XtraDB and Aria) to behave the same way. For example,
normally a multi-row insert which tries to violate a UNIQUE
contraint is completely rolled back on XtraDB/InnoDB, but
might be partially executed on Aria. With the IGNORE clause,
the statement will be partially executed in both engines.

Starting from MariaDB 5.5.28 duplicate key errors also
generate warnings. The OLD_MODE server variable can be used
to prevent this.










URL: https://mariadb.com/kb/en/ignore/
 MySQL  localhost:3306  SQL > \? INSERT
Syntax
------
INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]
 [INTO] tbl_name [PARTITION (partition_list)] [(col,...)]
 {VALUES | VALUE} ({expr | DEFAULT},...),(...),...
 [ ON DUPLICATE KEY UPDATE
 col=expr
 [, col=expr] ... ]

Or:

INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]
 [INTO] tbl_name [PARTITION (partition_list)]
 SET col={expr | DEFAULT}, ...
 [ ON DUPLICATE KEY UPDATE
 col=expr
 [, col=expr] ... ]

Or:

INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]
 [INTO] tbl_name [PARTITION (partition_list)] [(col,...)]
 SELECT ...
 [ ON DUPLICATE KEY UPDATE
 col=expr
 [, col=expr] ... ]

The INSERT statement is used to insert new rows into an
existing table. The INSERT ... VALUES
and INSERT ... SET forms of the statement insert rows based
on explicitly specified values. The INSERT ... SELECT form
inserts rows selected from another table or tables. INSERT
... SELECT is discussed further in the INSERT ... SELECT
article.

The table name can be specified in the form db_name.tbl_name
or, if a default database is selected, in the form tbl_name
(see Identifier Qualifiers). This allows to use INSERT ...
SELECT to copy rows between different databases.

The PARTITION clause was introduced in MariaDB 10.0. It can
be used in both the INSERT and the SELECT part. See
Partition Pruning and Selection for details.

The columns list is optional. It specifies which values are
explicitly inserted, and in which order. If this clause is
not specified, all values must be explicitly specified, in
the same order they are listed in the table definition.

The list of value follow the VALUES or VALUE keyword (which
are interchangeable, regardless how much values you want to
insert), and is wrapped by parenthesis. The values must be
listed in the same order as the columns list. It is possible
to specify more than one list to insert more than one rows
with a single statement. If many rows are inserted, this is
a speed optimization.

For one-row statements, the SET clause may be more simple,
because you don't need to remember the columns order. All
values are specified in the form col = expr.

Values can also be specified in the form of a SQL expression
or subquery. However, the subquery cannot access the same
table that is named in the INTO clause.

If you use the LOW_PRIORITY keyword, execution of the INSERT
is delayed until no other clients are reading from the
table. If you use the HIGH_PRIORITY keyword, the statement
has the same priority as SELECTs. This affects only storage
engines that use only table-level locking (MyISAM, MEMORY,
MERGE). However, if one of these keywords is specified,
concurrent inserts cannot be used. See HIGH_PRIORITY and
LOW_PRIORITY clauses for details.

INSERT DELAYED

For more details on the DELAYED option, see INSERT DELAYED.

HIGH PRIORITY and LOW PRIORITY

See HIGH_PRIORITY and LOW_PRIORITY.

Defaults and Duplicate Values

See INSERT - Default & Duplicate Values for details..

INSERT IGNORE

See INSERT IGNORE.

INSERT ON DUPLICATE KEY UPDATE

See INSERT ON DUPLICATE KEY UPDATE.

Examples
--------
Specifying the column names:

INSERT INTO person (first_name, last_name) VALUES ('John',
'Doe');

Inserting more than 1 row at a time:

INSERT INTO tbl_name VALUES (1, "row 1"), (2, "row 2");

Using the SET clause:

INSERT INTO person SET first_name = 'John', last_name =
'Doe';

SELECTing from another table:

INSERT INTO contractor SELECT * FROM person WHERE status =
'c';

See INSERT ON DUPLICATE KEY UPDATE and INSERT IGNORE for
further examples.



URL: https://mariadb.com/kb/en/insert/
 MySQL  localhost:3306  SQL > \? INSERT \? Default &amp; Duplicate Values
No help items found matching INSERT \? Default &amp; Duplicate Values
 MySQL  localhost:3306  SQL > \? INSERT DELAYED
Syntax
------
INSERT DELAYED ...

Description
-----------
The DELAYED option for the INSERT
statement is a MariaDB/MySQL extension to standard SQL that
is very useful if you have
clients that cannot or need not wait for the INSERT to
complete. This is a common situation when you use MariaDB
for logging and you
also periodically run SELECT and UPDATE
statements that take a long time to complete.

When a client uses INSERT DELAYED, it gets an okay from the
server at once, and the row is queued to be inserted when
the table is not in
use by any other thread.

Another major benefit of using INSERT DELAYED is that
inserts from many clients are bundled together and written
in one block. This
is much faster than performing many separate inserts.

Note that INSERT DELAYED is slower than a normal
 INSERT if the table is not otherwise in use. There is also
the additional overhead for the server to handle a separate
thread for each
table for which there are delayed rows. This means that you
should use
INSERT DELAYED only when you are really sure that you need
it.

The queued rows are held only in memory until they are
inserted into the table.
This means that if you terminate mysqld forcibly (for
example, with kill -9) or
if mysqld dies unexpectedly, any queued rows that have not
been written to disk
are lost.

The number of concurrent INSERT DELAYED threads is limited
by the max_delayed_threads server system variables. If it is
set to 0, INSERT DELAYED is disabled. The session value can
be equal to the global value, or 0 to disable this statement
for the current session. If this limit has been reached, the
DELAYED clause will be silently ignore for subsequent
statements (no error will be produced).

There are some constraints on the use of DELAYED:
INSERT DELAYED works only with MyISAM, MEMORY, ARCHIVE,
 and BLACKHOLE tables. If you execute INSERT DELAYED with
another storage engine, you will get an error like this:
ERROR 1616 (HY000): DELAYED option not supported for table
'tab_name'
For MyISAM tables, if there are no free blocks in the middle
of the data
 file, concurrent SELECT and INSERT statements are
supported. Under these
 circumstances, you very seldom need to use INSERT DELAYED
 with MyISAM.
INSERT DELAYED should be used only for
 INSERT statements that specify value lists. The server
 ignores DELAYED for INSERT ... SELECT
 or INSERT ... ON DUPLICATE KEY UPDATE statements.
Because the INSERT DELAYED statement returns immediately,
 before the rows are inserted, you cannot use
 LAST_INSERT_ID() to get the
 AUTO_INCREMENT value that the statement might generate.
DELAYED rows are not visible to SELECT
 statements until they actually have been inserted.
After INSERT DELAYED, ROW_COUNT() returns the number of the
rows you tried to insert, not the number of the successful
writes.
DELAYED is ignored on slave replication servers, so that
 INSERT DELAYED is treated as a normal
 INSERT on slaves. This is because
 DELAYED could cause the slave to have different data than
 the master. INSERT DELAYED statements are not safe for
replication.
Pending INSERT DELAYED statements are lost if a table is
 write locked and ALTER TABLE is used to modify the table
structure.
INSERT DELAYED is not supported for views. If you try, you
will get an error like this: ERROR 1347 (HY000):
'view_name' is not BASE TABLE
INSERT DELAYED is not supported for partitioned tables.
INSERT DELAYED is not supported within stored programs.



URL: https://mariadb.com/kb/en/insert-delayed/
 MySQL  localhost:3306  SQL > \? INSERT IGNORE
Ignoring Errors

Normally INSERT stops and rolls back when it encounters an
error.

By using the IGNORE keyword all errors are converted to
warnings, which will not stop inserts of additional rows.

The IGNORE and DELAYED options are ignored when you use ON
DUPLICATE KEY UPDATE.

Incompatibilities

MariaDB until 5.5.28
MySQL and MariaDB before 5.5.28 didn't give warnings for
duplicate key errors when using IGNORE.
You can get the old behaviour if you set OLD_MODE to
NO_DUP_KEY_WARNINGS_WITH_IGNORE

Examples
--------
CREATE TABLE t1 (x INT UNIQUE);

INSERT INTO t1 VALUES(1),(2);

INSERT INTO t1 VALUES(2),(3);
ERROR 1062 (23000): Duplicate entry '2' for key 'x'
SELECT * FROM t1;

+------+
| x |
+------+
| 1 |
| 2 |
+------+
2 rows in set (0.00 sec)

INSERT IGNORE INTO t1 VALUES(2),(3);
Query OK, 1 row affected, 1 warning (0.04 sec)

SHOW WARNINGS;

+---------+------+---------------------------------+
| Level | Code | Message |
+---------+------+---------------------------------+
| Warning | 1062 | Duplicate entry '2' for key 'x' |
+---------+------+---------------------------------+

SELECT * FROM t1;

+------+
| x |
+------+
| 1 |
| 2 |
| 3 |
+------+

See INSERT ON DUPLICATE KEY UPDATE for further examples
using that syntax.



URL: https://mariadb.com/kb/en/insert-ignore/
 MySQL  localhost:3306  SQL > \? INSERT ON DUPLICATE KEY UPDATE
Syntax
------
INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]
 [INTO] tbl_name [PARTITION (partition_list)] [(col,...)]
 {VALUES | VALUE} ({expr | DEFAULT},...),(...),...
 [ ON DUPLICATE KEY UPDATE
 col=expr
 [, col=expr] ... ]

Or:

INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]
 [INTO] tbl_name [PARTITION (partition_list)]
 SET col={expr | DEFAULT}, ...
 [ ON DUPLICATE KEY UPDATE
 col=expr
 [, col=expr] ... ]

Or:

INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]
 [INTO] tbl_name [PARTITION (partition_list)] [(col,...)]
 SELECT ...
 [ ON DUPLICATE KEY UPDATE
 col=expr
 [, col=expr] ... ]

Description
-----------
INSERT ... ON DUPLICATE KEY UPDATE is a MariaDB/MySQL
extension to the INSERT statement that, if it finds a
duplicate unique or primary key, will instead perform an
UPDATE.

The row/s affected value is reported as 1 if a row is
inserted, and 2 if a row is updated, unless the API's
CLIENT_FOUND_ROWS flag is set.

If more than one unique index is matched, only the first is
updated. It is not recommended to use this statement on
tables with more than one unique index.

If the table has an AUTO_INCREMENT primary key and the
statement inserts or updates a row, the LAST_INSERT_ID()
function returns its AUTO_INCREMENT value.

The VALUES() function can only be used in a ON DUPLICATE KEY
UPDATE clause and has no meaning in any other context. It
returns the column values from the INSERT portion of the
statement. This function is particularly useful for
multi-rows inserts.

The IGNORE and DELAYED options are ignored when you use ON
DUPLICATE KEY UPDATE.

The PARTITION clause was introduced in MariaDB 10.0. See
Partition Pruning and Selection for details.

This statement activates INSERT and UPDATE triggers. See
Trigger Overview for details.

See also a similar statement, REPLACE.

Examples
--------
CREATE TABLE ins_duplicate (id INT PRIMARY KEY, animal
VARCHAR(30));
INSERT INTO ins_duplicate VALUES (1,'Aardvark'),
(2,'Cheetah'), (3,'Zebra');

If there is no existing key, the statement runs as a regular
INSERT:

INSERT INTO ins_duplicate VALUES (4,'Gorilla') ON
DUPLICATE KEY UPDATE animal='Gorilla';
Query OK, 1 row affected (0.07 sec)

SELECT * FROM ins_duplicate;
+----+----------+
| id | animal |
+----+----------+
| 1 | Aardvark |
| 2 | Cheetah |
| 3 | Zebra |
| 4 | Gorilla |
+----+----------+

A regular INSERT with a primary key value of 1 will fail,
due to the existing key:

INSERT INTO ins_duplicate VALUES (1,'Antelope');
ERROR 1062 (23000): Duplicate entry '1' for key
'PRIMARY'

However, we can use an INSERT ON DUPLICATE KEY UPDATE
instead:

INSERT INTO ins_duplicate VALUES (1,'Antelope') ON
DUPLICATE KEY UPDATE animal='Antelope';
Query OK, 2 rows affected (0.09 sec)

Note that there are two rows reported as affected, but this
refers only to the UPDATE.

SELECT * FROM ins_duplicate;
+----+----------+
| id | animal |
+----+----------+
| 1 | Antelope |
| 2 | Cheetah |
| 3 | Zebra |
| 4 | Gorilla |
+----+----------+

Adding a second unique column:

ALTER TABLE ins_duplicate ADD id2 INT;
UPDATE ins_duplicate SET id2=id+10;
ALTER TABLE ins_duplicate ADD UNIQUE KEY(id2);

Where two rows match the unique keys match, only the first
is updated. This can be unsafe and is not recommended unless
you are certain what you are doing. Note that the warning
shown below appears in MariaDB 5.5 and before, but has been
removed in MariaDB 10.0, as MariaDB now assumes that the
keys are checked in order, as shown in SHOW CREATE TABLE.

INSERT INTO ins_duplicate VALUES (2,'Lion',13) ON
DUPLICATE KEY UPDATE animal='Lion';
Query OK, 2 rows affected, 1 warning (0.06 sec)

SHOW WARNINGS;
+-------+------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------+
| Level | Code | Message |
+-------+------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------+
| Note | 1592 | Unsafe statement written to the binary log
using statement format since BINLOG_FORMAT = STATEMENT.
INSERT... ON DUPLICATE KEY UPDATE on a table with more than
one UNIQUE KEY is unsafe |
+-------+------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------+

SELECT * FROM ins_duplicate;
+----+----------+------+
| id | animal | id2 |
+----+----------+------+
| 1 | Antelope | 11 |
| 2 | Lion | 12 |
| 3 | Zebra | 13 |
| 4 | Gorilla | 14 |
+----+----------+------+

Although the third row with an id of 3 has an id2 of 13,
which also matched, it was not updated.

Changing id to an auto_increment field. If a new row is
added, the auto_increment is moved forward. If the row is
updated, it remains the same.

ALTER TABLE `ins_duplicate` CHANGE `id` `id` INT( 11 ) NOT
NULL AUTO_INCREMENT;
ALTER TABLE ins_duplicate DROP id2;
SELECT Auto_increment FROM INFORMATION_SCHEMA.TABLES WHERE
TABLE_NAME='ins_duplicate';
+----------------+
| Auto_increment |
+----------------+
| 5 |
+----------------+

INSERT INTO ins_duplicate VALUES (2,'Leopard') ON
DUPLICATE KEY UPDATE animal='Leopard';
Query OK, 2 rows affected (0.00 sec)

SELECT Auto_increment FROM INFORMATION_SCHEMA.TABLES WHERE
TABLE_NAME='ins_duplicate';
+----------------+
| Auto_increment |
+----------------+
| 5 |
+----------------+

INSERT INTO ins_duplicate VALUES (5,'Wild Dog') ON
DUPLICATE KEY UPDATE animal='Wild Dog';
Query OK, 1 row affected (0.09 sec)

SELECT * FROM ins_duplicate;
+----+----------+
| id | animal |
+----+----------+
| 1 | Antelope |
| 2 | Leopard |
| 3 | Zebra |
| 4 | Gorilla |
| 5 | Wild Dog |
+----+----------+

SELECT Auto_increment FROM INFORMATION_SCHEMA.TABLES WHERE
TABLE_NAME='ins_duplicate';
+----------------+
| Auto_increment |
+----------------+
| 6 |
+----------------+

Refering to column values from the INSERT portion of the
statement:

INSERT INTO table (a,b,c) VALUES (1,2,3),(4,5,6)
 ON DUPLICATE KEY UPDATE c=VALUES(a)+VALUES(b);

See the VALUES() function for more.



URL:
https://mariadb.com/kb/en/insert-on-duplicate-key-update/
 MySQL  localhost:3306  SQL > \? INSERT SELECT
Syntax
------
INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]
 [INTO] tbl_name [(col_name,...)]
 SELECT ...
 [ ON DUPLICATE KEY UPDATE col_name=expr, ... ]

Description
-----------
With INSERT ... SELECT, you can quickly insert many rows
into a table from one or more other tables. For example:

INSERT INTO tbl_temp2 (fld_id)
 SELECT tbl_temp1.fld_order_id
 FROM tbl_temp1 WHERE tbl_temp1.fld_order_id > 100;

tbl_name can also be specified in the form db_name.tbl_name
(see Identifier Qualifiers). This allows to copy rows
between different databases.

If the new table has a primary key or UNIQUE indexes, you
can use IGNORE to handle duplicate key errors during the
query. The newer values will not be inserted if an identical
value already exists.

REPLACE can be used instead of INSERT to prevent duplicates
on UNIQUE indexes by deleting old values. In that case, ON
DUPLICATE KEY UPDATE cannot be used.

INSERT ... SELECT works for tables which already exist. To
create a table for a given resultset, you can use CREATE
TABLE ... SELECT.



URL: https://mariadb.com/kb/en/insert-select/
 MySQL  localhost:3306  SQL > \? INTERSECT
INTERSECT was introduced in MariaDB 10.3.0.

The result of an intersect is the intersection of right and
left SELECT results, i.e. only records that are present in
both result sets will be included in the result of the
operation.

Syntax
------
SELECT ...
(INTERSECT | EXCEPT | UNION [ALL | DISTINCT]) SELECT ...
[(INTERSECT | EXCEPT | UNION [ALL | DISTINCT]) SELECT ...]
[ORDER BY [column [, column ...]]]
[LIMIT {[offset,] row_count | row_count OFFSET offset}]

Please note:
ALL is not supported by INTERSECT (and it is difficult to
make sense of ALL with INTERSECT).
Brackets for explicit operation precedence are not
supported; use a subquery in the FROM clause as a
workaround).

Description
-----------
MariaDB has supported INTERSECT (as well as EXCEPT) in
addition to UNION since MariaDB 10.3.

All behavior for naming columns, ORDER BY and LIMIT is the
same as for UNION.

INTERSECT implicitly supposes a DISTINCT operation.

The result of an intersect is the intersection of right and
left SELECT results, i.e. only records that are present in
both result sets will be included in the result of the
operation.

INTERSECT has higher precedence than UNION and EXCEPT. If
possible it will be executed linearly but if not it will be
translated to a subquery in the FROM clause:

(select a,b from t1)
union
(select c,d from t2)
intersect
(select e,f from t3)
union
(select 4,4);

will be translated to:

(select a,b from t1)
union
select c,d from
 ((select c,d from t2)
 intersect
 (select e,f from t3)) dummy_subselect
union
(select 4,4)



Parentheses

From MariaDB 10.4.0, parentheses can be used to specify
precedence. Before this, a syntax error would be returned.

Examples
--------
Show customers which are employees:

(SELECT e_name AS name, email FROM employees)
INTERSECT
(SELECT c_name AS name, email FROM customers);

Difference between UNION, EXCEPT and INTERSECT:

CREATE TABLE seqs (i INT);
INSERT INTO seqs VALUES (1),(2),(3),(4),(5),(6);

SELECT i FROM seqs WHERE i =3;

+------+
| i |
+------+
| 1 |
| 2 |
| 3 |
| 4 |
| 5 |
| 6 |
+------+

SELECT i FROM seqs WHERE i =3;

+------+
| i |
+------+
| 1 |
| 2 |
+------+

SELECT i FROM seqs WHERE i =3;

+------+
| i |
+------+
| 3 |
+------+

Parentheses for specifying precedence, from MariaDB 10.4.0

CREATE OR REPLACE TABLE t1 (a INT);
CREATE OR REPLACE TABLE t2 (b INT);
CREATE OR REPLACE TABLE t3 (c INT);

INSERT INTO t1 VALUES (1),(2),(3),(4);
INSERT INTO t2 VALUES (5),(6);
INSERT INTO t3 VALUES (1),(6);

((SELECT a FROM t1) UNION (SELECT b FROM t2)) INTERSECT
(SELECT c FROM t3);
+------+
| a |
+------+
| 1 |
| 6 |
+------+

(SELECT a FROM t1) UNION ((SELECT b FROM t2) INTERSECT
(SELECT c FROM t3));
+------+
| a |
+------+
| 1 |
| 2 |
| 3 |
| 4 |
| 6 |
+------+



URL: https://mariadb.com/kb/en/intersect/
 MySQL  localhost:3306  SQL > \? JOIN Syntax
Description
-----------
MariaDB supports the following JOIN syntaxes for
the table_references part of SELECT statements and
multiple-table DELETE and UPDATE statements:

table_references:
 table_reference [, table_reference] ...

table_reference:
 table_factor
 | join_table

table_factor:
 tbl_name [PARTITION (partition_list)]
 [query_system_time_period_specification] [[AS] alias]
[index_hint_list]
 | table_subquery [query_system_time_period_specification]
[AS] alias
 | ( table_references )
 | { ON table_reference LEFT OUTER JOIN table_reference
 ON conditional_expr }

join_table:
 table_reference [INNER | CROSS] JOIN table_factor
[join_condition]
 | table_reference STRAIGHT_JOIN table_factor
 | table_reference STRAIGHT_JOIN table_factor ON
conditional_expr
 | table_reference {LEFT|RIGHT} [OUTER] JOIN table_reference
join_condition
 | table_reference NATURAL [{LEFT|RIGHT} [OUTER]] JOIN
table_factor

join_condition:
 ON conditional_expr
 | USING (column_list)

query_system_time_period_specification:
 FOR SYSTEM_TIME AS OF point_in_time
 | FOR SYSTEM_TIME BETWEEN point_in_time AND point_in_time
 | FOR SYSTEM_TIME FROM point_in_time TO point_in_time
 | FOR SYSTEM_TIME ALL

point_in_time:
 [TIMESTAMP] expression
 | TRANSACTION expression

index_hint_list:
 index_hint [, index_hint] ...

index_hint:
 USE {INDEX|KEY}
 [{FOR {JOIN|ORDER BY|GROUP BY}] ([index_list])
 | IGNORE {INDEX|KEY}
 [{FOR {JOIN|ORDER BY|GROUP BY}] (index_list)
 | FORCE {INDEX|KEY}
 [{FOR {JOIN|ORDER BY|GROUP BY}] (index_list)

index_list:
 index_name [, index_name] ...

A table reference is also known as a join expression.

Each table can also be specified as db_name.tabl_name. This
allows to write queries which involve multiple databases.
See Identifier Qualifiers for syntax details.

The syntax of table_factor is extended in comparison with
the
SQL Standard. The latter accepts only table_reference, not a
list of them inside a pair of parentheses.

This is a conservative extension if we consider each comma
in a list of
table_reference items as equivalent to an inner join. For
example:

SELECT * FROM t1 LEFT JOIN (t2, t3, t4)
 ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)

is equivalent to:

SELECT * FROM t1 LEFT JOIN (t2 CROSS JOIN t3 CROSS JOIN t4)
 ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)

In MariaDB, CROSS JOIN is a syntactic equivalent to
INNER JOIN (they can replace each other). In standard SQL,
they are not equivalent. INNER JOIN is used with an
ON clause, CROSS JOIN is used otherwise.

In general, parentheses can be ignored in join expressions
containing only
inner join operations. MariaDB also supports nested joins
(see
http://dev.mysql.com/doc/refman/5.1/en/nested-join-optimization.html).

See System-versioned tables for more information
about FOR SYSTEM_TIME syntax.

Index hints can be specified to affect how the MariaDB
optimizer makes
use of indexes. For more information, see How to force query
plans.

Examples
--------
SELECT left_tbl.*
 FROM left_tbl LEFT JOIN right_tbl ON left_tbl.id =
right_tbl.id
 WHERE right_tbl.id IS NULL;











URL: https://mariadb.com/kb/en/join-syntax/
 MySQL  localhost:3306  SQL > \? LIMIT
Description
-----------
Use the LIMIT clause to restrict the number of returned
rows. When you use a single
integer n with LIMIT, the first n rows will be returned. Use
the ORDER BY
clause to control which rows come first. You can also select
a number of rows after an offset
using either of the following:

LIMIT offset, row_count
LIMIT row_count OFFSET offset

When you provide an offset m with a limit n, the first m
rows will be ignored, and the
following n rows will be returned.

Executing an UPDATE with the LIMIT clause is not safe for
replication.

Since MariaDB 10.0.11, LIMIT 0 has been an exception to this
rule (see MDEV-6170).

Beginning in MariaDB 5.5.21, there is a LIMIT ROWS EXAMINED
optimization which provides the
means to terminate the execution of SELECT statements which
examine too
many rows, and thus use too many resources. See LIMIT ROWS
EXAMINED.

Multi-Table Updates

Until MariaDB 10.3.1, it was not possible to use LIMIT (or
ORDER BY) in a multi-table UPDATE statement. This
restriction was lifted in MariaDB 10.3.2.

GROUP_CONCAT

Starting from MariaDB 10.3.3, it is possible to use LIMIT
with GROUP_CONCAT().

Examples
--------
CREATE TABLE members (name VARCHAR(20));
INSERT INTO members
VALUES('Jagdish'),('Kenny'),('Rokurou'),('Immaculada');

SELECT * FROM members;

+------------+
| name |
+------------+
| Jagdish |
| Kenny |
| Rokurou |
| Immaculada |
+------------+

Select the first two names (no ordering specified):

SELECT * FROM members LIMIT 2;

+---------+
| name |
+---------+
| Jagdish |
| Kenny |
+---------+

All the names in alphabetical order:

SELECT * FROM members ORDER BY name;

+------------+
| name |
+------------+
| Immaculada |
| Jagdish |
| Kenny |
| Rokurou |
+------------+

The first two names, ordered alphabetically:

SELECT * FROM members ORDER BY name LIMIT 2;

+------------+
| name |
+------------+
| Immaculada |
| Jagdish |
+------------+

The third name, ordered alphabetically (the first name would
be offset zero, so the third is offset two):

SELECT * FROM members ORDER BY name LIMIT 2,1;

+-------+
| name |
+-------+
| Kenny |
+-------+

From MariaDB 10.3.2, LIMIT can be used in a multi-table
update:

CREATE TABLE warehouse (product_id INT, qty INT);
INSERT INTO warehouse VALUES
(1,100),(2,100),(3,100),(4,100);

CREATE TABLE store (product_id INT, qty INT);
INSERT INTO store VALUES (1,5),(2,5),(3,5),(4,5);

UPDATE warehouse,store SET warehouse.qty = warehouse.qty-2,
store.qty = store.qty+2
 WHERE (warehouse.product_id = store.product_id AND
store.product_id >= 1)
 ORDER BY store.product_id DESC LIMIT 2;

SELECT * FROM warehouse;

+------------+------+
| product_id | qty |
+------------+------+
| 1 | 100 |
| 2 | 100 |
| 3 | 98 |
| 4 | 98 |
+------------+------+

SELECT * FROM store;

+------------+------+
| product_id | qty |
+------------+------+
| 1 | 5 |
| 2 | 5 |
| 3 | 7 |
| 4 | 7 |
+------------+------+

From MariaDB 10.3.3, LIMIT can be used with GROUP_CONCAT,
so, for example, given the following table:

CREATE TABLE d (dd DATE, cc INT);

INSERT INTO d VALUES ('2017-01-01',1);
INSERT INTO d VALUES ('2017-01-02',2);
INSERT INTO d VALUES ('2017-01-04',3);

the following query:

SELECT SUBSTRING_INDEX(GROUP_CONCAT(CONCAT_WS(":",dd,cc)
ORDER BY cc DESC),",",1) FROM d;

+----------------------------------------------------------------------------+
| SUBSTRING_INDEX(GROUP_CONCAT(CONCAT_WS(":",dd,cc) ORDER
BY cc DESC),",",1) |
+----------------------------------------------------------------------------+
| 2017-01-04:3 |
+----------------------------------------------------------------------------+

can be more simply rewritten as:

SELECT GROUP_CONCAT(CONCAT_WS(":",dd,cc) ORDER BY cc DESC
LIMIT 1) FROM d;

+-------------------------------------------------------------+
| GROUP_CONCAT(CONCAT_WS(":",dd,cc) ORDER BY cc DESC LIMIT
1) |
+-------------------------------------------------------------+
| 2017-01-04:3 |
+-------------------------------------------------------------+



URL: https://mariadb.com/kb/en/limit/
 MySQL  localhost:3306  SQL > \? LOAD DATA INFILE
Syntax
------
LOAD DATA [LOW_PRIORITY | CONCURRENT] [LOCAL] INFILE
'file_name'
 [REPLACE | IGNORE]
 INTO TABLE tbl_name
 [CHARACTER SET charset_name]
 [{FIELDS | COLUMNS}
 [TERMINATED BY 'string']
 [[OPTIONALLY] ENCLOSED BY 'char']
 [ESCAPED BY 'char']
 ]
 [LINES
 [STARTING BY 'string']
 [TERMINATED BY 'string']
 ]
 [IGNORE number LINES]
 [(col_name_or_user_var,...)]
 [SET col_name = expr,...]

Description
-----------
Reads rows from a text file into the designated table on the
database at a very high speed. The file name must be given
as a literal string.

Files are written to disk using the SELECT INTO OUTFILE
statement. You can then read the files back into a table
using the LOAD DATA INFILE statement. The FIELDS and LINES
clauses are the same in both statements. These clauses are
optional, but if both are specified then the FIELDS clause
must precede LINES.

In releases after MariaDB 5.5, LOAD DATA INFILE is unsafe
for statement-based replication.

Executing this statement activates INSERT triggers.

REPLACE and IGNORE

In cases where you load data from a file into a table that
already contains data and has a Primary Key, you may
encounter issues where the statement attempts to insert a
row with a Primary Key that already exists. When this
happens, the statement fails with Error 1064, protecting the
data already on the table. In cases where you want MariaDB
to overwrite duplicates, use the REPLACE keyword.

The REPLACE keyword works like the REPLACE statement. Here,
the statement attempts to load the data from the file. If
the row does not exist, it adds it to the table. If the row
contains an existing Primary Key, it replaces the table
data. That is, in the event of a conflict, it assumes the
file contains the desired row.

This operation can cause a degradation in load speed by a
factor of 20 or more if the part that has already been
loaded is larger than the capacity of the InnoDB Buffer
Pool. This happens because it causes a lot of turnaround in
the Buffer Pool.

Use the IGNORE keyword when you want to skip any rows that
contain a conflicting Primary Key. Here, the statement
attempts to load the data from the file. If the row does not
exist, it adds it to the table. If the row contains an
existing Primary Key, it ignores the addition request and
moves on to the next. That is, in the event of a conflict,
it assumes the table contains the desired row.

LOCAL

When you issue this statement, the Server attempts to read
files from the host file system. Using the LOCAL keyword,
the statement instead attempts to read files from the
client. This allows you to insert files from the client's
local file system into the database.

In the event that you don't want the server to permit this
operation, (such as for security reasons), you can disable
support using local_infile. When this system variable is set
to 0, MariaDB rejects LOAD DATA LOCAL INFILE statements,
failing with an error message.

Character-sets

When the statement opens the file, it attempts to read the
contents using the default character-set, as defined by the
character_set_database system variable.

In the cases where the file was written using a
character-set other than the default, you can specify the
character-set to use with the CHARACTER SET clause in the
statement. It ignores character-sets specified by the SET
NAMES statement and by the character_set_client system
variable. Setting the CHARACTER SET clause to a value of
binary indicates "no conversion."

The statement interprets all fields in the file as having
the same character-set, regardless of the column data type.
To properly interpret file contents, you must ensure that it
was written with the correct character-set. If you write a
data file with mysqldump -T or with the SELECT INTO OUTFILE
statement with the mysql client, be sure to use the
--default-character-set option, so that the output is
written with the desired character-set.

When using mixed character sets, use the CHARACTER SET
clause in both SELECT INTO OUTFILE and LOAD DATA INFILE to
ensure that MariaDB correctly interprets the escape
sequences.

The character_set_filesystem system variable controls the
interpretation of the filename.

It is currently not possible to load data files that use the
ucs2 character set.

Priority and Concurrency

In loading data from a file, there's a risk that the
statement will attempt insertions concurrent with reads from
another client, which can result in the read serving a
result-set that contains only part of the update from the
LOAD DATA INFILE statement.

Using the LOW_PRIORITY keyword, MariaDB delays insertions
until no other clients are reading from the table.
Alternatively, you can use the CONCURRENT keyword to perform
concurrent insertion.

The LOW_PRIORITY and CONCURRENT keywords are mutually
exclusive. They cannot be used in the same statement.

Progress Reporting

Since MariaDB 5.3, the LOAD DATA INFILE statement supports
progress reporting. You may find this useful when dealing
with long-running operations. Using another client you can
issue a SHOW PROCESSLIST query to check the progress of the
data load.

Using mysqlimport

MariaDB ships with a separate utility for loading data from
files: mysqlimport. It operates by sending LOAD DATA INFILE
statements to the server.

Using mysqlimport you can compress the file using the
--compress option, to get better performance over slow
networks, providing both the client and server support the
compressed protocol. Use the --local option to load from the
local file system.

Indexing

In cases where the storage engine supports ALTER TABLE...
DISABLE KEYS statements, the LOAD DATA INFILE statement
automatically disables indexes during the execution.



URL: https://mariadb.com/kb/en/load-data-infile/
 MySQL  localhost:3306  SQL > \? LOAD XML
Syntax
------
LOAD XML [LOW_PRIORITY | CONCURRENT] [LOCAL] INFILE
'file_name'
 [REPLACE | IGNORE]
 INTO TABLE [db_name.]tbl_name
 [CHARACTER SET charset_name]
 [ROWS IDENTIFIED BY '']
 [IGNORE number {LINES | ROWS}]
 [(column_or_user_var,...)]
 [SET col_name = expr,...]

Description
-----------
The LOAD XML statement reads data from an XML file into a
table. The
file_name must be given as a literal string. The tagname in
the
optional ROWS IDENTIFIED BY clause must also be given as a
literal
string, and must be surrounded by angle brackets (< and >).

LOAD XML acts as the complement of running the mysql client
in XML
output mode (that is, starting the client with the --xml
option). To
write data from a table to an XML file, use a command such
as the
following one from the system shell:

shell> mysql --xml -e 'SELECT * FROM mytable' > file.xml

To read the file back into a table, use LOAD XML INFILE. By
default,
the  element is considered to be the equivalent of a
database
table row; this can be changed using the ROWS IDENTIFIED BY
clause.

This statement supports three different XML formats:
Column names as attributes and column values as attribute
values:

Column names as tags and column values as the content of
these tags:

 value1
 value2

Column names are the name attributes of  tags, and values
are
 the contents of these tags:

 value1
 value2

 This is the format used by other tools, such as mysqldump.

All 3 formats can be used in the same XML file; the import
routine
automatically detects the format for each row and interprets
it
correctly. Tags are matched based on the tag or attribute
name and the
column name.

The following clauses work essentially the same way for LOAD
XML as
they do for LOAD DATA:
LOW_PRIORITY or CONCURRENT
LOCAL
REPLACE or IGNORE
CHARACTER SET
(column_or_user_var,...)
SET

See LOAD DATA for more information about these clauses.

The IGNORE number LINES or IGNORE number ROWS clause causes
the first
number rows in the XML file to be skipped. It is analogous
to the LOAD
DATA statement's IGNORE ... LINES clause.

If the LOW_PRIORITY keyword is used, insertions are delayed
until no other clients are reading from the table. The
CONCURRENT keyword allowes the use of concurrent inserts.
These clauses cannot be specified together.

This statement activates INSERT triggers.



URL: https://mariadb.com/kb/en/load-xml/
 MySQL  localhost:3306  SQL > \? LOCK IN SHARE MODE
When LOCK IN SHARE MODE is specified in a SELECT statement,
MariaDB will wait until all transactions that have modified
the rows are committed. Then, a write lock is acquired. All
transactions can read the rows, but if they want to modify
them, they have to wait until your transaction is committed.

InnoDB/XtraDB supports row-level locking. selected rows can
be locked using LOCK IN SHARE MODE or FOR UPDATE. In both
cases, a lock is acquired on the rows read by the query, and
it will be released when the current transaction is
committed.

If autocommit is set to 1, the LOCK IN SHARE MODE and FOR
UPDATE clauses have no effect.



URL: https://mariadb.com/kb/en/lock-in-share-mode/
 MySQL  localhost:3306  SQL > \? Non-Recursive Common Table Expressions Overview
Common Table Expressions (CTEs) are a standard SQL feature,
and are essentially temporary named result sets. There are
two kinds of CTEs: Non-Recursive, which this article covers;
and Recursive.

Common table expressions were introduced in MariaDB 10.2.1.

Non-Recursive CTEs

The WITH keyword signifies a CTE. It is given a name,
followed by a body (the main query) as follows:

CTEs are similar to derived tables. For example

WITH engineers AS
 ( SELECT * FROM employees
 WHERE dept = 'Engineering' )

SELECT * FROM engineers
WHERE ...

SELECT * FROM
 ( SELECT * FROM employees
 WHERE dept = 'Engineering' ) AS engineers
WHERE
...

A non-recursive CTE is basically a query-local VIEW. There
are several advantages and caveats to them. The syntax is
more readable than nested FROM (SELECT ...).
A CTE can refer to another and it can be referenced from
multiple places.

A CTE referencing Another CTE

Using this format makes for a more readable SQL than a
nested FROM(SELECT ...) clause. Below is an example of this:

WITH engineers AS (
SELECT * FROM employees
WHERE dept IN('Development','Support') ),
eu_engineers AS ( SELECT * FROM engineers WHERE country
IN('NL',...) )
SELECT
...
FROM eu_engineers;

Multiple Uses of a CTE

This can be an 'anti-self join', for example:

WITH engineers AS (
SELECT * FROM employees
WHERE dept IN('Development','Support') )

SELECT * FROM engineers E1
WHERE NOT EXISTS
 (SELECT 1 FROM engineers E2
 WHERE E2.country=E1.country
 AND E2.name  E1.name );

Or, for year-over-year comparisons, for example:

WITH sales_product_year AS (
SELECT product, YEAR(ship_date) AS year,
SUM(price) AS total_amt
FROM item_sales
GROUP BY product, year )

SELECT *
FROM sales_product_year CUR,
sales_product_year PREV,
WHERE CUR.product=PREV.product
AND CUR.year=PREV.year + 1
AND CUR.total_amt > PREV.total_amt

Another use is to compare individuals against their group.
Below is an example of how this might be executed:

WITH sales_product_year AS (
SELECT product,
YEAR(ship_date) AS year,
SUM(price) AS total_amt
FROM item_sales
GROUP BY product, year
)

SELECT *
FROM sales_product_year S1
WHERE
total_amt >
 (SELECT 0.1 * SUM(total_amt)
 FROM sales_product_year S2
 WHERE S2.year = S1.year)










URL:
https://mariadb.com/kb/en/non-recursive-common-table-expressions-overview/
 MySQL  localhost:3306  SQL > \? ORDER BY
Description
-----------
Use the ORDER BY clause to order a resultset, such as that
are returned from a SELECT
statement. You can specify just a column or use any
expression with functions. If you are
using the GROUP BY clause, you can use grouping functions in
ORDER BY.
Ordering is done after grouping.

You can use multiple ordering expressions, separated by
commas. Rows will be sorted by
the first expression, then by the second expression if they
have the same value for the
first, and so on.

You can use the keywords ASC and DESC after each ordering
expression to
force that ordering to be ascending or descending,
respectively. Ordering is ascending
by default.

You can also use a single integer as the ordering
expression. If you use an integer n,
the results will be ordered by the nth column in the select
expression.

When string values are compared, they are compared as if by
the STRCMP
function. STRCMP ignores trailing whitespace and may
normalize
characters and ignore case, depending on the collation in
use.

Starting from MariaDB 5.5.35 duplicated entries in the ORDER
BY clause are removed. MySQL 5.6 also removes duplicated
fields.

ORDER BY can also be used to order the activities of a
DELETE or UPDATE statement (usually with the LIMIT clause).

Until MariaDB 10.3.1, it was not possible to use ORDER BY
(or LIMIT) in a multi-table UPDATE statement. This
restriction was lifted in MariaDB 10.3.2.

Examples
--------
CREATE TABLE seq (i INT, x VARCHAR(1));
INSERT INTO seq VALUES (1,'a'), (2,'b'), (3,'b'),
(4,'f'), (5,'e');

SELECT * FROM seq ORDER BY i;

+------+------+
| i | x |
+------+------+
| 1 | a |
| 2 | b |
| 3 | b |
| 4 | f |
| 5 | e |
+------+------+

SELECT * FROM seq ORDER BY i DESC;

+------+------+
| i | x |
+------+------+
| 5 | e |
| 4 | f |
| 3 | b |
| 2 | b |
| 1 | a |
+------+------+

SELECT * FROM seq ORDER BY x,i;

+------+------+
| i | x |
+------+------+
| 1 | a |
| 2 | b |
| 3 | b |
| 5 | e |
| 4 | f |
+------+------+

ORDER BY in an UPDATE statement, in conjunction with LIMIT:

UPDATE seq SET x='z' WHERE x='b' ORDER BY i DESC LIMIT
1;

SELECT * FROM seq;

+------+------+
| i | x |
+------+------+
| 1 | a |
| 2 | b |
| 3 | z |
| 4 | f |
| 5 | e |
+------+------+

From MariaDB 10.3.2, ORDER BY can be used in a multi-table
update:

CREATE TABLE warehouse (product_id INT, qty INT);
INSERT INTO warehouse VALUES
(1,100),(2,100),(3,100),(4,100);

CREATE TABLE store (product_id INT, qty INT);
INSERT INTO store VALUES (1,5),(2,5),(3,5),(4,5);

UPDATE warehouse,store SET warehouse.qty = warehouse.qty-2,
store.qty = store.qty+2
 WHERE (warehouse.product_id = store.product_id AND
store.product_id >= 1)
 ORDER BY store.product_id DESC LIMIT 2;

SELECT * FROM warehouse;

+------------+------+
| product_id | qty |
+------------+------+
| 1 | 100 |
| 2 | 100 |
| 3 | 98 |
| 4 | 98 |
+------------+------+

SELECT * FROM store;

+------------+------+
| product_id | qty |
+------------+------+
| 1 | 5 |
| 2 | 5 |
| 3 | 7 |
| 4 | 7 |
+------------+------+



URL: https://mariadb.com/kb/en/order-by/
 MySQL  localhost:3306  SQL > \? PROCEDURE
The PROCEDURE clause of SELECT passes the whole result set
to a Procedure which will process it. These Procedures are
not Stored Procedures, and can only be written in the C
language, so it is necessary to recompile the server.

Currently, the only available procedure is ANALYSE, which
examines the resultset and suggests the optimal datatypes
for each column. It is defined in the sql/sql_analyse.cc
file, and can be used as an example to create more
Procedures.

This clause cannot be used in a view's definition.



URL: https://mariadb.com/kb/en/procedure/
 MySQL  localhost:3306  SQL > \? Recursive Common Table Expressions Overview
Recursive Common Table Expressions have been supported since
MariaDB 10.2.2.

Common Table Expressions (CTEs) are a standard SQL feature,
and are essentially temporary named result sets. CTEs first
appeared in the SQL standard in 1999, and the first
implementations began appearing in 2007.

There are two kinds of CTEs:
Non-recursive
Recursive, which this article covers.

SQL is generally poor at recursive structures.

CTEs permit a query to reference itself. A recursive CTE
will repeatedly execute subsets of the data until it obtains
the complete result set. This makes it particularly useful
for handing hierarchical or tree-structured data.

Syntax example

WITH RECURSIVE signifies a recursive CTE. It is given a
name, followed by a body (the main query) as follows:


Computation

Given the following structure:

First execute the anchor part of the query:

Next, execute the recursive part of the query:




Summary so far

with recursive R as (
 select anchor_data
 union [all]
 select recursive_part
 from R, ...
)
select ...
Compute anchor_data
Compute recursive_part to get the new data
if (new data is non-empty) goto 2;

CAST to avoid truncating data

As currently implemented by MariaDB and by the SQL Standard,
data may be truncated if not correctly cast. It is necessary
to CAST the column to the correct width if the CTE's
recursive part produces wider values for a column than the
CTE's nonrecursive part. Some other DBMS give an error in
this situation, and MariaDB's behavior may change in future
- see MDEV-12325. See the examples below.

Examples
--------
Transitive closure - determining bus destinations

Sample data:

CREATE TABLE bus_routes (origin varchar(50), dst
varchar(50));
INSERT INTO bus_routes VALUES
 ('New York', 'Boston'),
 ('Boston', 'New York'),
 ('New York', 'Washington'),
 ('Washington', 'Boston'),
 ('Washington', 'Raleigh');

Now, we want to return the bus destinations with New York as
the origin:

WITH RECURSIVE bus_dst as (
 SELECT origin as dst FROM bus_routes WHERE origin='New
York'
 UNION
 SELECT bus_routes.dst FROM bus_routes, bus_dst WHERE
bus_dst.dst= bus_routes.origin
)
SELECT * FROM bus_dst;

+------------+
| dst |
+------------+
| New York |
| Boston |
| Washington |
| Raleigh |
+------------+

The above example is computed as follows:

First, the anchor data is calculated:
Starting from New York
Boston and Washington are added

Next, the recursive part:
Starting from Boston and then Washington
Raleigh is added
UNION excludes nodes that are already present.

Computing paths - determining bus routes

This time, we are trying to get bus routes such as “New
York -> Washington -> Raleigh”.

Using the same sample data as the previous example:

WITH RECURSIVE paths (cur_path, cur_dest) AS (
 SELECT origin, origin FROM bus_routes WHERE origin='New
York'
 UNION
 SELECT CONCAT(paths.cur_path, ',', bus_routes.dst),
bus_routes.dst
 FROM paths, bus_routes
 WHERE paths.cur_dest = bus_routes.origin AND
 LOCATE(bus_routes.dst, paths.cur_path)=0
)
SELECT * FROM paths;

+-----------------------------+------------+
| cur_path | cur_dest |
+-----------------------------+------------+
| New York | New York |
| New York,Boston | Boston |
| New York,Washington | Washington |
| New York,Washington,Boston | Boston |
| New York,Washington,Raleigh | Raleigh |
+-----------------------------+------------+

CAST to avoid data truncation

In the following example, data is truncated because the
results are not specifically cast to a wide enough type:

WITH RECURSIVE tbl AS (
 SELECT NULL AS col
 UNION
 SELECT "THIS NEVER SHOWS UP" AS col FROM tbl
)
+------+
| col |
+------+
| NULL |
| |
+------+

Explicitly use CAST to overcome this:

WITH RECURSIVE tbl AS (
 SELECT CAST(NULL AS CHAR(50)) AS col
 UNION SELECT "THIS NEVER SHOWS UP" AS col FROM tbl
)
SELECT * FROM tbl;

+---------------------+
| col |
+---------------------+
| NULL |
| THIS NEVER SHOWS UP |
+---------------------+










URL:
https://mariadb.com/kb/en/recursive-common-table-expressions-overview/
 MySQL  localhost:3306  SQL > \? REPLACE
Syntax
------
REPLACE [LOW_PRIORITY | DELAYED]
 [INTO] tbl_name [PARTITION (partition_list)] [(col,...)]
 {VALUES | VALUE} ({expr | DEFAULT},...),(...),...

Or:

REPLACE [LOW_PRIORITY | DELAYED]
 [INTO] tbl_name [PARTITION (partition_list)]
 SET col={expr | DEFAULT}, ...

Or:

REPLACE [LOW_PRIORITY | DELAYED]
 [INTO] tbl_name [PARTITION (partition_list)] [(col,...)]
 SELECT ...

Description
-----------
 REPLACE works exactly like
 INSERT, except that if an old row in the table
 has the same value as a new row for a PRIMARY KEY or a
 UNIQUE index, the old row is deleted before the new row is
 inserted. If the table has more than one UNIQUE keys, it is
possible that the new row conflicts with more than one row.
In this case, all conflicting rows will be deleted.

The table name can be specified in the form db_name.tbl_name
or, if a default database is selected, in the form tbl_name
(see Identifier Qualifiers). This allows to use REPLACE ...
SELECT to copy rows between different databases.

Basically it works like this:

BEGIN;
SELECT 1 FROM t1 WHERE key=# FOR UPDATE;
IF found-row
 DELETE FROM t1 WHERE key=# ;
 INSERT INTO t1 VALUES (...);
ENDIF
END;

The above can be replaced with:

REPLACE INTO t1 VALUES (...)

 REPLACE is a MariaDB/MySQL extension to the SQL standard.
It
 either inserts, or deletes and inserts. For other
MariaDB/MySQL extensions to
 standard SQL --- that also handle duplicate values --- see
IGNORE and INSERT ON DUPLICATE KEY UPDATE.

Note that unless the table has a PRIMARY KEY or
 UNIQUE index, using a REPLACE statement
makes no sense. It becomes equivalent to INSERT, because
there is no index to be used to determine whether a new row
duplicates another.

Values for all columns are taken from the values specified
in the
 REPLACE statement. Any missing columns are set to their
default values, just as happens for INSERT. You cannot refer
to values from the current row and use them in the new row.
If you use an
assignment such as 'SET col = col + 1', the
reference to the column name on the right hand side is
treated as
 DEFAULT(col), so the assignment is equivalent to
 'SET col = DEFAULT(col) + 1'.

To use REPLACE, you must have both the
 INSERT and DELETE privileges
for the table.

There are some gotchas you should be aware of, before using
REPLACE:
If there is an AUTO_INCREMENT field, a new value will be
generated.
If there are foreign keys, ON DELETE action will be
activated by REPLACE.
Triggers on DELETE and INSERT will be activated by REPLACE.

To avoid some of these behaviors, you can use INSERT ... ON
DUPLICATE KEY UPDATE.

The PARTITION clause was introduced in MariaDB 10.0. See
Partition Pruning and Selection for details.

This statement activates INSERT and DELETE triggers. See
Trigger Overview for details.



URL: https://mariadb.com/kb/en/replace/
 MySQL  localhost:3306  SQL > \? SELECT
Syntax
------
SELECT
 [ALL | DISTINCT | DISTINCTROW]
 [HIGH_PRIORITY]
 [STRAIGHT_JOIN]
 [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]
 [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS]
 select_expr [, select_expr ...]
 [ FROM table_references
 [WHERE where_condition]
 [GROUP BY {col_name | expr | position} [ASC | DESC], ...
[WITH ROLLUP]]
 [HAVING where_condition]
 [ORDER BY {col_name | expr | position} [ASC | DESC], ...]
 [LIMIT {[offset,] row_count | row_count OFFSET offset}]
 procedure|[PROCEDURE procedure_name(argument_list)]
 [INTO OUTFILE 'file_name' [CHARACTER SET charset_name]
[export_options]

INTO DUMPFILE 'file_name' | INTO var_name [, var_name] ] |


 [[FOR UPDATE | LOCK IN SHARE MODE] [WAIT n | NOWAIT] ] ]

export_options:
 [{FIELDS | COLUMNS}
 [TERMINATED BY 'string']
 [[OPTIONALLY] ENCLOSED BY 'char']
 [ESCAPED BY 'char']
 ]
 [LINES
 [STARTING BY 'string']
 [TERMINATED BY 'string']
 ]

Description
-----------
SELECT is used to retrieve rows selected from one or more
tables, and can include UNION statements and subqueries.
Each select_expr expression indicates a column or data that
you want to retrieve. You
must have at least one select expression. See Select
Expressions below.

The FROM clause indicates the table or tables from which to
retrieve rows.
Use either a single table name or a JOIN expression. See
JOIN
for details. If no table is involved, FROM DUAL can be
specified.

The PARTITION clause was introduced in MariaDB 10.0. See
Partition Pruning and Selection for details.
Each table can also be specified as db_name.tabl_name. Each
column can also be specified as tbl_name.col_name or even
db_name.tbl_name.col_name. This allows to write queries
which involve multiple databases. See Identifier Qualifiers
for syntax details.

The WHERE clause, if given, indicates the condition or
 conditions that rows must satisfy to be selected.
 where_condition is an expression that evaluates to true for
 each row to be selected. The statement selects all rows if
there is no WHERE
 clause.
In the WHERE clause, you can use any of the functions and
 operators that MariaDB supports, except for aggregate
(summary) functions. See Functions and Operators and
Functions and Modifiers for use with GROUP BY (aggregate).

Use the ORDER BY clause to order the results.

Use the LIMIT clause allows you to restrict the results to
only
a certain number of rows, optionally with an offset.

Use the GROUP BY and HAVING clauses to group
rows together when they have columns or computed values in
common.

SELECT can also be used to retrieve rows computed without
reference to
any table.

Select Expressions

A SELECT statement must contain one or more select
expressions, separated
by commas. Each select expression can be one of the
following:
The name of a column.
Any expression using functions and operators.
* to select all columns from all tables in the FROM clause.
tbl_name.* to select all columns from just the table
tbl_name.

When specifying a column, you can either use just the column
name or qualify the column
name with the name of the table using tbl_name.col_name. The
qualified form is
useful if you are joining multiple tables in the FROM
clause. If you do not qualify the
column names when selecting from multiple tables, MariaDB
will try to find the column in
each table. It is an error if that column name exists in
multiple tables.

You can quote column names using backticks. If you are
qualifying column names
with table names, quote each part separately as
`tbl_name`.`col_name`.

If you use any grouping functions
in any of the select expressions, all rows in your results
will be implicitly grouped, as if
you had used GROUP BY NULL.

DISTINCT

A query may produce some identical rows. By default, all
rows are retrieved, even when their values are the same. To
explicitly specify that you want to retrieve identical rows,
use the ALL option. If you want duplicates to be removed
from the resultset, use the DISTINCT option. DISTINCTROW is
a synonym for DISTINCT. See also COUNT DISTINCT and SELECT
UNIQUE in Oracle mode.

INTO

The INTO clause is used to specify that the query results
should be written to a file or variable.
SELECT INTO OUTFILE - formatting and writing the result to
an external file.
SELECT INTO DUMPFILE - binary-safe writing of the
unformatted results to an external file.
SELECT INTO Variable - selecting and setting variables.

The reverse of SELECT INTO OUTFILE is LOAD DATA.

WAIT/NOWAIT

Set the lock wait timeout. See WAIT and NOWAIT.

PROCEDURE

Passes the whole result set to a C Procedure. See PROCEDURE
and PROCEDURE ANALYSE (the only built-in procedure not
requiring the server to be recompiled).


max_statement_time clause

By using max_statement_time in conjunction with SET
STATEMENT, it is possible to limit the execution time of
individual queries. For example:

SET STATEMENT max_statement_time=100 FOR
 SELECT field1 FROM table_name ORDER BY field1;



URL: https://mariadb.com/kb/en/select/
 MySQL  localhost:3306  SQL > \? SELECT INTO DUMPFILE
Syntax
------
SELECT ... INTO DUMPFILE 'file_path'

Description
-----------
SELECT ... INTO DUMPFILE is a SELECT clause which writes the
resultset into a single unformatted row, without any
separators, in a file. The results will not be returned to
the client.

file_path can be an absolute path, or a relative path
starting from the data directory. It can only be specified
as a string literal, not as a variable. However, the
statement can be dynamically composed and executed as a
prepared statement to work around this limitation.

This statement is binary-safe and so is particularly useful
for writing BLOB values to file. It can be used, for
example, to copy an image or an audio document from the
database to a file. SELECT ... INTO FILE can be used to save
a text file.

The file must not exist. It cannot be overwritten. A user
needs the FILE privilege to run this statement. Also,
MariaDB needs permission to write files in the specified
location. If the secure_file_priv system variable is set to
a non-empty directory name, the file can only be written to
that directory.

Since MariaDB 5.1, the character_set_filesystem system
variable has controlled interpretation of file names that
are given as literal strings.

Example

SELECT _utf8'Hello world!' INTO DUMPFILE '/tmp/world';

SELECT LOAD_FILE('/tmp/world') AS world;

+--------------+
| world |
+--------------+
| Hello world! |
+--------------+



URL: https://mariadb.com/kb/en/select-into-dumpfile/
 MySQL  localhost:3306  SQL > \? SELECT INTO OUTFILE
Syntax
------
SELECT ... INTO OUTFILE 'file_name'
 [CHARACTER SET charset_name]
 [export_options]

export_options:
 [{FIELDS | COLUMNS}
 [TERMINATED BY 'string']
 [[OPTIONALLY] ENCLOSED BY 'char']
 [ESCAPED BY 'char']
 ]
 [LINES
 [STARTING BY 'string']
 [TERMINATED BY 'string']
 ]

Description
-----------
SELECT INTO OUTFILE writes the resulting rows to a file, and
allows the use of column and row terminators to specify a
particular output format. The default is to terminate fields
with tabs (\t) and lines with newlines (\n).

The file must not exist. It cannot be overwritten. A user
needs the FILE privilege to run this statement. Also,
MariaDB needs permission to write files in the specified
location. If the secure_file_priv system variable is set to
a non-empty directory name, the file can only be written to
that directory.

The LOAD DATA INFILE statement complements SELECT INTO
OUTFILE.

Character-sets

The CHARACTER SET clause specifies the character set in
which the results are to be written. Without the clause, no
conversion takes place (the binary character set). In this
case, if there are multiple character sets, the output will
contain these too, and may not easily be able to be
reloaded.

In cases where you have two servers using different
character-sets, using SELECT INTO OUTFILE to transfer data
from one to the other can have unexpected results. To ensure
that MariaDB correctly interprets the escape sequences, use
the CHARACTER SET clause on both the SELECT INTO OUTFILE
statement and the subsequent LOAD DATA INFILE statement.

Example

The following example produces a file in the CSV format:

SELECT customer_id, firstname, surname INTO OUTFILE
'/exportdata/customers.txt'
 FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
 LINES TERMINATED BY '\n'
 FROM customers;



URL: https://mariadb.com/kb/en/select-into-outfile/
 MySQL  localhost:3306  SQL > \? SELECT WITH ROLLUP
Syntax
------
See SELECT for the full syntax.

Description
-----------
The WITH ROLLUP modifier adds extra rows to the resultset
that represent super-aggregate summaries. The
super-aggregated column is represented by a NULL value.
Multiple aggregates over different columns will be added if
there are multiple GROUP BY columns.

The LIMIT clause can be used at the same time, and is
applied after the WITH ROLLUP rows have been added.

WITH ROLLUP cannot be used with ORDER BY. Some sorting is
still possible by using ASC or DESC clauses with the GROUP
BY column, although the super-aggregate rows will always be
added last.

Examples
--------
These examples use the following sample table

CREATE TABLE booksales (
 country VARCHAR(35), genre
ENUM('fiction','non-fiction'), year YEAR, sales INT);

INSERT INTO booksales VALUES
 ('Senegal','fiction',2014,12234),
('Senegal','fiction',2015,15647),
 ('Senegal','non-fiction',2014,64980),
('Senegal','non-fiction',2015,78901),
 ('Paraguay','fiction',2014,87970),
('Paraguay','fiction',2015,76940),
 ('Paraguay','non-fiction',2014,8760),
('Paraguay','non-fiction',2015,9030);

The addition of the WITH ROLLUP modifier in this example
adds an extra row that aggregates both years:

SELECT year, SUM(sales) FROM booksales GROUP BY year;

+------+------------+
| year | SUM(sales) |
+------+------------+
| 2014 | 173944 |
| 2015 | 180518 |
+------+------------+
2 rows in set (0.08 sec)

SELECT year, SUM(sales) FROM booksales GROUP BY year WITH
ROLLUP;

+------+------------+
| year | SUM(sales) |
+------+------------+
| 2014 | 173944 |
| 2015 | 180518 |
| NULL | 354462 |
+------+------------+

In the following example, each time the genre, the year or
the country change, another super-aggregate row is added:

SELECT country, year, genre, SUM(sales)
 FROM booksales GROUP BY country, year, genre;

+----------+------+-------------+------------+
| country | year | genre | SUM(sales) |
+----------+------+-------------+------------+
| Paraguay | 2014 | fiction | 87970 |
| Paraguay | 2014 | non-fiction | 8760 |
| Paraguay | 2015 | fiction | 76940 |
| Paraguay | 2015 | non-fiction | 9030 |
| Senegal | 2014 | fiction | 12234 |
| Senegal | 2014 | non-fiction | 64980 |
| Senegal | 2015 | fiction | 15647 |
| Senegal | 2015 | non-fiction | 78901 |
+----------+------+-------------+------------+

SELECT country, year, genre, SUM(sales)
 FROM booksales GROUP BY country, year, genre WITH ROLLUP;

+----------+------+-------------+------------+
| country | year | genre | SUM(sales) |
+----------+------+-------------+------------+
| Paraguay | 2014 | fiction | 87970 |
| Paraguay | 2014 | non-fiction | 8760 |
| Paraguay | 2014 | NULL | 96730 |
| Paraguay | 2015 | fiction | 76940 |
| Paraguay | 2015 | non-fiction | 9030 |
| Paraguay | 2015 | NULL | 85970 |
| Paraguay | NULL | NULL | 182700 |
| Senegal | 2014 | fiction | 12234 |
| Senegal | 2014 | non-fiction | 64980 |
| Senegal | 2014 | NULL | 77214 |
| Senegal | 2015 | fiction | 15647 |
| Senegal | 2015 | non-fiction | 78901 |
| Senegal | 2015 | NULL | 94548 |
| Senegal | NULL | NULL | 171762 |
| NULL | NULL | NULL | 354462 |
+----------+------+-------------+------------+

The LIMIT clause, applied after WITH ROLLUP:

SELECT country, year, genre, SUM(sales)
 FROM booksales GROUP BY country, year, genre WITH ROLLUP
LIMIT 4;

+----------+------+-------------+------------+
| country | year | genre | SUM(sales) |
+----------+------+-------------+------------+
| Paraguay | 2014 | fiction | 87970 |
| Paraguay | 2014 | non-fiction | 8760 |
| Paraguay | 2014 | NULL | 96730 |
| Paraguay | 2015 | fiction | 76940 |
+----------+------+-------------+------------+

Sorting by year descending:

SELECT country, year, genre, SUM(sales)
 FROM booksales GROUP BY country, year DESC, genre WITH
ROLLUP;

+----------+------+-------------+------------+
| country | year | genre | SUM(sales) |
+----------+------+-------------+------------+
| Paraguay | 2015 | fiction | 76940 |
| Paraguay | 2015 | non-fiction | 9030 |
| Paraguay | 2015 | NULL | 85970 |
| Paraguay | 2014 | fiction | 87970 |
| Paraguay | 2014 | non-fiction | 8760 |
| Paraguay | 2014 | NULL | 96730 |
| Paraguay | NULL | NULL | 182700 |
| Senegal | 2015 | fiction | 15647 |
| Senegal | 2015 | non-fiction | 78901 |
| Senegal | 2015 | NULL | 94548 |
| Senegal | 2014 | fiction | 12234 |
| Senegal | 2014 | non-fiction | 64980 |
| Senegal | 2014 | NULL | 77214 |
| Senegal | NULL | NULL | 171762 |
| NULL | NULL | NULL | 354462 |
+----------+------+-------------+------------+



URL: https://mariadb.com/kb/en/select-with-rollup/
 MySQL  localhost:3306  SQL > \? UNION
UNION is used to combine the results from multiple SELECT
statements into a single result set.

Syntax
------
SELECT ...
UNION [ALL | DISTINCT] SELECT ...
[UNION [ALL | DISTINCT] SELECT ...]
[ORDER BY [column [, column ...]]]
[LIMIT {[offset,] row_count | row_count OFFSET offset}]

Description
-----------
UNION is used to combine the results from multiple SELECT
statements into a single result set.

The column names from the first SELECT statement are used as
the column names for the results returned. Selected columns
listed in corresponding positions of each SELECT statement
should have the same data type. (For example, the first
column selected by the first statement should have the same
type as the first column selected by the other statements.)

If they don't, the type and length of the columns in the
result take into account the values returned by all of the
SELECTs, so there is no need for explicit casting. Note that
currently this is not the case for recursive CTEs - see
MDEV-12325.

Table names can be specified as db_name.tbl_name. This
permits writing UNIONs which involve multiple databases. See
Identifier Qualifiers for syntax details.

UNION queries cannot be used with aggregate functions.

ALL/DISTINCT

The ALL keyword causes duplicate rows to be preserved. The
DISTINCT keyword (the default if the keyword is omitted)
causes duplicate rows to be removed by the results.

UNION ALL and UNION DISTINCT can both be present in a query.
In this case, UNION DISTINCT will override any UNION ALLs to
its left.

Until MariaDB 10.1.1, all UNION ALL statements required the
server to create a temporary table. Since MariaDB 10.1.1,
the server can in most cases execute UNION ALL without
creating a temporary table, improving performance (see
MDEV-334).

ORDER BY and LIMIT

Individual SELECTs can contain their own ORDER BY and LIMIT
clauses. In this case, the individual queries need to be
wrapped between parentheses. However, this does not affect
the order of the UNION, so they only are useful to limit the
record read by one SELECT.

The UNION can have global ORDER BY and LIMIT clauses, which
affect the whole resultset. If the columns retrieved by
individual SELECT statements have an alias (AS), the ORDER
BY must use that alias, not the real column names.

HIGH_PRIORITY

Specifying a query as HIGH_PRIORITY will not work inside a
UNION. If applied to the first SELECT, it will be ignored.
Applying to a later SELECT results in a syntax error:

ERROR 1234 (42000): Incorrect usage/placement of
'HIGH_PRIORITY'

SELECT ... INTO ...

Individual SELECTs cannot be written INTO DUMPFILE or INTO
OUTFILE. If the last SELECT statement specifies INTO
DUMPFILE or INTO OUTFILE, the entire result of the UNION
will be written. Placing the clause after any other SELECT
will result in a syntax error.

If the result is a single row, SELECT ... INTO @var_name can
also be used.


Parentheses

From MariaDB 10.4.0, parentheses can be used to specify
precedence. Before this, a syntax error would be returned.

Examples
--------
UNION between tables having different column names:

(SELECT e_name AS name, email FROM employees)
UNION
(SELECT c_name AS name, email FROM customers);

Specifying the UNION's global order and limiting total
rows:

(SELECT name, email FROM employees)
UNION
(SELECT name, email FROM customers)
ORDER BY name LIMIT 10;

Adding a constant row:

(SELECT 'John Doe' AS name, 'john.doe@example.net' AS
email)
UNION
(SELECT name, email FROM customers);

Differing types:

SELECT CAST('x' AS CHAR(1)) UNION SELECT REPEAT('y',4);
+----------------------+
| CAST('x' AS CHAR(1)) |
+----------------------+
| x |
| yyyy |
+----------------------+

Returning the results in order of each individual SELECT by
use of a sort column:

(SELECT 1 AS sort_column, e_name AS name, email FROM
employees)
UNION
(SELECT 2, c_name AS name, email FROM customers) ORDER BY
sort_column;

Difference between UNION, EXCEPT and INTERSECT:

CREATE TABLE seqs (i INT);
INSERT INTO seqs VALUES (1),(2),(3),(4),(5),(6);

SELECT i FROM seqs WHERE i =3;

+------+
| i |
+------+
| 1 |
| 2 |
| 3 |
| 4 |
| 5 |
| 6 |
+------+

SELECT i FROM seqs WHERE i =3;

+------+
| i |
+------+
| 1 |
| 2 |
+------+

SELECT i FROM seqs WHERE i =3;

+------+
| i |
+------+
| 3 |
+------+

Parentheses for specifying precedence, from MariaDB 10.4.0

CREATE OR REPLACE TABLE t1 (a INT);
CREATE OR REPLACE TABLE t2 (b INT);
CREATE OR REPLACE TABLE t3 (c INT);

INSERT INTO t1 VALUES (1),(2),(3),(4);
INSERT INTO t2 VALUES (5),(6);
INSERT INTO t3 VALUES (1),(6);

((SELECT a FROM t1) UNION (SELECT b FROM t2)) INTERSECT
(SELECT c FROM t3);
+------+
| a |
+------+
| 1 |
| 6 |
+------+

(SELECT a FROM t1) UNION ((SELECT b FROM t2) INTERSECT
(SELECT c FROM t3));
+------+
| a |
+------+
| 1 |
| 2 |
| 3 |
| 4 |
| 6 |
+------+



URL: https://mariadb.com/kb/en/union/
 MySQL  localhost:3306  SQL > \? UPDATE
Syntax
------
Single-table syntax:

UPDATE [LOW_PRIORITY] [IGNORE] table_reference
 [PARTITION (partition_list)]
 SET col1={expr1|DEFAULT} [,col2={expr2|DEFAULT}] ...
 [WHERE where_condition]
 [ORDER BY ...]
 [LIMIT row_count]

Multiple-table syntax:

UPDATE [LOW_PRIORITY] [IGNORE] table_references
 SET col1={expr1|DEFAULT} [, col2={expr2|DEFAULT}] ...
 [WHERE where_condition]

Description
-----------
For the single-table syntax, the UPDATE statement updates
columns of existing rows in the named table with new values.
The
SET clause indicates which columns to modify and the values
they should be given. Each value can be given as an
expression, or the keyword
DEFAULT to set a column explicitly to its default value. The
WHERE clause, if given, specifies the conditions that
identify
which rows to update. With no WHERE clause, all rows are
updated. If the ORDER BY clause is specified, the rows are
updated in the order that is specified. The LIMIT clause
places a limit on the number of rows that can be updated.

The PARTITION clause was introduced in MariaDB 10.0. See
Partition Pruning and Selection for details.

Until MariaDB 10.3.2, for the multiple-table syntax, UPDATE
updates rows in each
table named in table_references that satisfy the conditions.
In this case,
ORDER BY and LIMIT cannot be used. This restriction was
lifted in MariaDB 10.3.2 and both clauses can be used with
multiple-table updates. An UPDATE can also reference tables
which are located in different databases; see Identifier
Qualifiers for the syntax.

where_condition is an expression that evaluates to true for
each row to be updated.

table_references and where_condition are as
specified as described in SELECT.

Assignments are evaluated in left-to-right order, unless the
SIMULTANEOUS_ASSIGNMENT sql_mode (available from MariaDB
10.3.5) is set, in which case the UPDATE statement evaluates
all assignments simultaneously.

You need the UPDATE privilege only for columns referenced in
an UPDATE that are actually updated. You need only the
SELECT privilege for any columns that are read but
not modified. See GRANT.

The UPDATE statement supports the following modifiers:
If you use the LOW_PRIORITY keyword, execution of
 the UPDATE is delayed until no other clients are reading
from
 the table. This affects only storage engines that use only
table-level
 locking (MyISAM, MEMORY, MERGE). See HIGH_PRIORITY and
LOW_PRIORITY clauses for details.
If you use the IGNORE keyword, the update statement does
 not abort even if errors occur during the update. Rows for
which
 duplicate-key conflicts occur are not updated. Rows for
which columns are
 updated to values that would cause data conversion errors
are updated to the
 closest valid values instead.

UPDATE Statements With the Same Source and Target

From MariaDB 10.3.2, UPDATE statements may have the same
source and target.

For example, given the following table:

DROP TABLE t1;

CREATE TABLE t1 (c1 INT, c2 INT);
INSERT INTO t1 VALUES (10,10), (20,20);

Until MariaDB 10.3.1, the following UPDATE statement would
not work:

UPDATE t1 SET c1=c1+1 WHERE c2=(SELECT MAX(c2) FROM t1);
ERROR 1093 (HY000): Table 't1' is specified twice,
 both as a target for 'UPDATE' and as a separate source
for data

From MariaDB 10.3.2, the statement executes successfully:

UPDATE t1 SET c1=c1+1 WHERE c2=(SELECT MAX(c2) FROM t1);

SELECT * FROM t1;

+------+------+
| c1 | c2 |
+------+------+
| 10 | 10 |
| 21 | 20 |
+------+------+

Example

Single-table syntax:

UPDATE table_name SET column1 = value1, column2 = value2
WHERE id=100;

Multiple-table syntax:

UPDATE tab1, tab2 SET tab1.column1 = value1, tab1.column2 =
value2 WHERE tab1.id = tab2.id;



URL: https://mariadb.com/kb/en/update/
 MySQL  localhost:3306  SQL > \? WITH
The WITH keyword signifies a Common Table Expression (CTE).
It allows you to refer to a subquery expression many times
in a query, as if having a temporary table that only exists
for the duration of a query.

There are two kinds of CTEs:
Non-Recursive
Recursive

Common Table Expression WITH was introduced in MariaDB
10.2.1.

Recursive WITH has been supported since MariaDB 10.2.2.

Syntax
------
WITH [RECURSIVE] table_reference as (SELECT ...)
 SELECT ...

You can use table_reference as any normal table in the
external SELECT part. You can also use WITH in sub queries.
WITH can also be used with EXPLAIN and SELECT.

Below is an example with the WITH at the top level:

WITH t AS (SELECT a FROM t1 WHERE b >= 'c')
 SELECT * FROM t2, t WHERE t2.c = t.a;

The example below uses WITH in a subquery:

SELECT t1.a, t1.b FROM t1, t2
 WHERE t1.a > t2.c
 AND t2.c IN(WITH t AS (SELECT * FROM t1 WHERE t1.a

URL: https://mariadb.com/kb/en/with/
 MySQL  localhost:3306  SQL > \exit
Bye!
